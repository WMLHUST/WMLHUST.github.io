---
title: CSAPP-2-信息的表示和处理
tags: [CSAPP]
categories: [系统原理,CSAPP]
comments: true
date: 2016-10-30 21:48:57 
updated: 2016-10-30 21:48:57 
description:
---

## 信息的表示和处理

### 开篇
对计算机底层数的位形式表示和运算有疑问的同学，非常推荐一读。各种细节问题，拨云见日，豁然开朗。

### 信息存储   
1. 数字表示，分三种情况：   
    1. 无符号整数，普通二进制形式
    2. 有符号整数，补码。
    3. 浮点数，IEEE 754标准。

2. 最小可寻址存储器单位：字节（byte），8个二进制位（bit），2个16进制字符表示。

3. 16进制记忆小技巧，记住A-10， C-12，F-15就可以了。

4. 字长   
计算机的字长表示的是，处理器一次能够处理的最长二进制位数。当然也依赖操作系统和编译器。但是编译器程序的整数字节数，比如int、long的最大长度，跟计算机字长无关。   
比如java不分32位、64位，所有的long都是8个字节，64位。这种想法主要源于，32位机器上C语言的long是4byte，64位机器上是8byte。坑啊。。

5. 字节序：大端、小端。   
前提：计算机读取主存的顺序是从低位到高位。莫忘，基本单位是字节   
大端：如同人阅读顺序。千位在低位内存，个位在高位内存。   
小端：intel处理器，和大端正好相反。   

    以数字 0x123456为例。随着内存地址递增的顺序：   
    大端：0x12  0x34    0x56    
    小端：0x56  0x34    0x12    
    
    字节是基本的存储和读取单位！！它的值是不变的,所以字节内部顺序是不变的。

6. 整数的三种表示方式：原码、反码、补码，这三种方式可以互相通过一定的运算转换，但是它们都是独立的表示方式，都可以独立地表示正、负整数。
    - 原码：最高位有效位，剩下的位决定值。这种表示方式最好理解。
    - 反码：最高位的权是，<img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large -({2^{w-1}-1})" style="border:none;">，其他跟补码是一样的。
    - 补码，现在计算机里大多用的就是补码，原因是加减操作可以使用统一的位操作。计算时，最高位的权为<img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large -({2^{w-1}})" style="border:none;">。<br>补码可以从原码转换过来，正数的补码表示跟其原码表示相同，负数的补码是原码的按位取反再加一。

    此外，负数的补码往前扩充1值是不变的，如0xFF表示-1，0xFFFF还是-1，注意二进制轴上的对应关系。

7. 一个w位的有符号数（补码）表达范围<img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large [-{2^{w-1}},2^{w-1}-1]" style="border:none;">。   
w位无符号数表达范围<img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large [0,{2^{w}-1}]" style="border:none;">。   
注意在位的角度它们的对应关系，比如32位补码-1的16进制表示为【0xFFFFFFFF】

8. C语言printf在输出的时候，%u-无符号整数，%d有符号整数，根据格式化指示符来解释入参的“二进制位”。   
还要注意如果要输出一个byte的二进制要用unsigned char \*指针，char \*指针会由于位扩展，输出扩展后的4个字节，根据原字节首位的情况，正数前面扩展0，负数扩展1。

9. 整数的加减法运算   

前提：在CPU看来，所有的数的二进制表示都是补码。所有的操作都是位上的操作。所有的溢出，高位都被直接截断丢掉。至于某一串二进制如何解释（有or无符号），这是人为的设定。   

结论：**减去一个二进制串，等于加上其逆元。** 逆元 = 二进制按位取反再+1。(是不是和原码转补码很像？但是切记，不是一个东西。)
减法运算，有符号整数无需多言，减去一个数等于加上该数的逆元。有符号整数也是如此，举例为证。

```c
//假设int是8位
 unsigned int a = 1;  //0b0000 0001
 unsigned int b = 2;  //0b0000 0010
 printf("%s\n", a-b>0?"true":"false");  //output:true
```

解释一下a-b的过程，先求b的逆元 0b1111 1110，与a相加，结果0b1111 1111，按补码解释也就是-1，按无符号整数解释是255，所以输出true。
那么如何判断加法运算是否溢出？画个二进制轴，特别好理解。

``` c
// 无符号加法
int uadd_ok(unsigned x, unsigned y)
{
   unsigned sum = x + y;
   return sum >= x;
}

// 有符号，分情况，正溢出or负溢出
int tadd_ok(int x, int y)
{
   int sum = x + y;
   int neg_over = x < 0 && y < 0 && sum > 0;
   int pos_over = x >= 0 && y >= 0 && sum < 0;

   return neg_over || pos_over;
}
```


10. 整数乘法   
同样，有符号与无符号在CPU看来，都是两个二进制串的同一个操作。对于乘法有可能溢出的情况，同样，保留后w位，截断高位。   
乘法通常都比较慢，需要10个时钟周期或更多。然而其他整数运算（例如加法、减法、位级运算和移位）只需要一个时钟周期。因此乘以一个常数，可以考虑用移位代替。即使乘法发生了溢出，也是有效的。如:   

```
x * 14;   
相当于 (x<<3) + (x<<2) + (x<<1); // 三个移位，两个加法   
也相当于 (x<<4) - (x<<1); // 两个移位，一个加法。   
```

11. 整数除法   
大多数机器上，整数除法比整数乘法更慢---需要30个或更多时钟周期。   
总是向零舍入。-3/2=-1; 3/2=1;   
除数如果是2的正数幂，可以通过右移位来实现，但是**无法推广到普通的除数**。其实是个分配律的问题x * (a + b + c) = x * a + x * b + x * c; 然而 x / (a + b + c)不行。   

12. 浮点数
直接说IEEE 754标准的浮点数表示。   
一个二进制串分为三部分。   
- 符号位，1位，决定正负。
- 阶码 E，对浮点数加权，2^E。C语言里float，8位；double, 11位。
- 尾数 M，二进制小数，计算分情况。C里float, 23位；double, 52位。

计算根据阶码分为三种，规格化、非规格化、特殊值，float为例：   
- 规格化，E各位不全为0也不全为1，即e!=0 && e!=255。E = e - 127。所以E的范围其实是[-126, 127] 。此时 M = m + 1。所以最后绝对值为 M·2^E = (m+1)·2^(e-127)。   
- 非规格化，全为0，e=0。E = 1 - 127. M = m。所以最后绝对值为 M·2^E = m·2^(-126)。 当m取最小值2^(-23) 时，这也是float能够表示的最小非零数，2^(-149)。
- 特殊值，全为1，e=255。当m=0时，根据符号位分别得到+∞和-∞。当m!=0时，得到NaN，意为 Not a Number。

至于为什么e=0时，M=m而不是M=m+1？   

此处结合e=0时，E也不是0-127，而是1-127,正好等于规格化的最小e，也是1-127。这个在非规格化向规格化过渡的时候，相同的指数值，保证整个f的值会随着m的增长而增大（线性的）。因此，对浮点数排序时，也可以像整数一样，直接比较其二进制位，从高位开始比较。   

这个设计很有意思，假如在非规格化时，E=0-127，M=1+m，非规格化最大数为E=-127,M=1 + (2^23 -1)/2^23，f= 2^E ·M=2^(-126) -2^(-150) 。规格化最小数为E=1-127，M=1+0，f'=2^(-126) 。（哎？f'>f，额这是哪里算错了吗？）f'-f=2^(-150).   

真实情况是，非规格化最大数为E=1-127，M=(2^23 -1)/2^23，f= 2^(-126) -2^(-149) ，规格化最小数仍然是f'= 2^(-126)。 f'-f=2 ^ (-149)。这正是相邻的两个非规格化数的间隔2^(-126) ·2^(-23) =2^(-149)。也就是说IEEE的这种设计保持了在非规格化和规格化数之间的一个平滑过渡。   

13. 强转与舍入   
- int转为float，不会溢出，但是可能被舍入，毕竟都只有2^32个状态，能表达的总信息量是一定的。如 2^24 +1和2^24 强转为float后，值为2^24.000000。舍入的时候会有一种特殊情况，称为向偶数舍入，在非有效位值正好是两个可能值的中间值时，我们倾向于通过取舍，使得有效位的最后一位为0.
- double转float, 可能溢出为-∞或+∞.
- float和double转int，向零舍入。如果出现溢出，则值会变成0b1000 0000，也就是-Min。此处可以注意下。

14. 浮点的运算   
主要是一点，**不可结合，和分配**，主要原因是，中间值可能会±∞或NaN。