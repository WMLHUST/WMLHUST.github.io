<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小本本</title>
  
  <subtitle>学而时习之，不亦说乎</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-25T01:36:29.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WordGe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer题目思路简结（三）</title>
    <link href="http://yoursite.com/2020/06/25/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/06/25/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2020-06-25T01:36:29.000Z</published>
    <updated>2020-06-25T01:36:29.000Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><pre><code>1. [剑指 Offer 50. 第一个只出现一次的字符](#剑指-offer-50-第一个只出现一次的字符)2. [剑指 Offer 51. 数组中的逆序对](#剑指-offer-51-数组中的逆序对)3. [剑指 Offer 52. 两个链表的第一个公共节点](#剑指-offer-52-两个链表的第一个公共节点)4. [剑指 Offer 53 - I. 在排序数组中查找数字 I](#剑指-offer-53---i-在排序数组中查找数字-i)5. [指 Offer 53 - II. 0～n-1中缺失的数字](#指-offer-53---ii-0n-1中缺失的数字)6. [剑指 Offer 54. 二叉搜索树的第k大节点](#剑指-offer-54-二叉搜索树的第k大节点)7. [剑指 Offer 55 - I. 二叉树的深度](#剑指-offer-55---i-二叉树的深度)8. [剑指 Offer 55 - II. 平衡二叉树](#剑指-offer-55---ii-平衡二叉树)9. [剑指 Offer 56 - I. 数组中数字出现的次数](#剑指-offer-56---i-数组中数字出现的次数)10. [剑指 Offer 56 - II. 数组中数字出现的次数 II](#剑指-offer-56---ii-数组中数字出现的次数-ii)11. [剑指 Offer 57 - II. 和为s的连续正数序列](#剑指-offer-57---ii-和为s的连续正数序列)12. [剑指 Offer 58 - I. 翻转单词顺序](#剑指-offer-58---i-翻转单词顺序)13. [剑指 Offer 58 - II. 左旋转字符串](#剑指-offer-58---ii-左旋转字符串)14. [剑指 Offer 59 - I. 滑动窗口的最大值](#剑指-offer-59---i-滑动窗口的最大值)15. [剑指 Offer 59 - II. 队列的最大值](#剑指-offer-59---ii-队列的最大值)16. [剑指 Offer 60. n个骰子的点数](#剑指-offer-60-n个骰子的点数)17. [剑指 Offer 61. 扑克牌中的顺子](#剑指-offer-61-扑克牌中的顺子)18. [剑指 Offer 62. 圆圈中最后剩下的数字](#剑指-offer-62-圆圈中最后剩下的数字)19. [剑指 Offer 63. 股票的最大利润](#剑指-offer-63-股票的最大利润)20. [剑指 Offer 64. 求1+2+…+n](#剑指-offer-64-求12n)21. [剑指 Offer 65. 不用加减乘除做加法](#剑指-offer-65-不用加减乘除做加法)22. [剑指 Offer 66. 构建乘积数组](#剑指-offer-66-构建乘积数组)23. [剑指 Offer 67. 把字符串转换成整数](#剑指-offer-67-把字符串转换成整数)24. [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](#剑指-offer-68---i-二叉搜索树的最近公共祖先)25. [剑指 Offer 68 - II. 二叉树的最近公共祖先](#剑指-offer-68---ii-二叉树的最近公共祖先)</code></pre><ol><li><a href="#完结散花-">完结散花 <del>~</del></a></li></ol><!-- /TOC --><h2 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a>剑指 Offer 50. 第一个只出现一次的字符</h2><p>遍历字符串，搞个map记录字符出现次数。再次遍历字符串，遇到出现次数为 1 的就返回。</p><h2 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a>剑指 Offer 51. 数组中的逆序对</h2><p>这题值得hard难度。<br>如果暴力解法，时间复杂度将是O(N^2)。比排序的O(NlogN)还大，那么可否先排序在比较，降低复杂度？<br>比如 [7, 5, 6, 4]   </p><ol><li>先均分为两部分 [7, 5] 和 [6, 4]，分别排序得到，[5, 7] 和 [4, 6]。</li><li>对于5，发现只比4大，说明只有一个[5, 4]，对于7，继续与6比较，而不用继续跟4比较，说明有[7, 4]、[7, 6] 两个。</li><li>继续分别针对[7，5] 和 [6, 4] 重复 <code>均分-&gt;排序-&gt;比较</code> 这个过程。分别只有一个结果[7, 5]和[6, 4]。</li><li>所以最终结果为 5 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 比较两个排好序的子数组</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">computePairs</span><span class="params">(arr1: List[int], arr2: List[int])</span> -&gt; int:</span></span><br><span class="line">            <span class="keyword">if</span> len(arr1) == <span class="number">0</span> <span class="keyword">or</span> len(arr2) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l = <span class="number">0</span></span><br><span class="line">            r = <span class="number">0</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> l&lt;len(arr1) :</span><br><span class="line">                <span class="keyword">while</span> r &lt; len(arr2) <span class="keyword">and</span> arr1[l] &gt; arr2[r]:</span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">                res += r</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 划分 &amp; 排序</span></span><br><span class="line">        nums2 = nums.copy()</span><br><span class="line">        left_arr = nums[:len(nums2)//<span class="number">2</span>]</span><br><span class="line">        right_arr = nums[len(nums2)//<span class="number">2</span>:]</span><br><span class="line">        left_arr.sort()</span><br><span class="line">        right_arr.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算本身结果，并递归子数组</span></span><br><span class="line">        <span class="keyword">return</span> computePairs(left_arr, right_arr) \</span><br><span class="line">               + self.reversePairs(nums[:len(nums)//<span class="number">2</span>]) \</span><br><span class="line">               + self.reversePairs(nums[len(nums)//<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a>剑指 Offer 52. 两个链表的第一个公共节点</h2><p>最简单的，先计算长度，然后比较两者的长度差，再利用快慢指针。<br>一个巧妙的办法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        c1 = headA</span><br><span class="line">        c2 = headB</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 最终c1和c2走的长度是相等的，LA + LB</span></span><br><span class="line">        <span class="comment"># 2. 如果不存在相交，c1走到B的结尾时会被赋值为None，此时c2也恰好走到A的结尾被赋值为None，刚好两者相等，跳出循环</span></span><br><span class="line">        <span class="keyword">while</span> c1 != c2:</span><br><span class="line">            c1 = c1.next <span class="keyword">if</span> c1 <span class="keyword">else</span> headB</span><br><span class="line">            c2 = c2.next <span class="keyword">if</span> c2 <span class="keyword">else</span> headA</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c1</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h2><p>先二分查找位置，再左右扩展。复杂度最差 O(N)，平均 O(logN) + O(M)。M为结果个数。如果M==N，则平均复杂度退化为 O(logN) + O(N)<br>再优化一下，可以先查左边界，再查右边界。就是 O(logN) 的复杂度，避免了最差O(N)的复杂度。   </p><p>都比暴力解法强吧 [doge][doge] </p><h2 id="指-Offer-53-II-0～n-1中缺失的数字"><a href="#指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="指 Offer 53 - II. 0～n-1中缺失的数字"></a>指 Offer 53 - II. 0～n-1中缺失的数字</h2><p>规律是：在缺失数左侧，每个数与其索引是相等的；在缺失数右侧，每个数 &gt; 其索引。因此可利用二分查找缺失数的位置。</p><h2 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a>剑指 Offer 54. 二叉搜索树的第k大节点</h2><p>按 <code>右子树 -&gt; 根 -&gt; 左子树</code> 的顺序遍历，使用全局变量记录还需遍历多少个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 返回</span></span><br><span class="line">        <span class="comment"># 1. 是否找到</span></span><br><span class="line">        <span class="comment"># 2. 对应的值</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(r: TreeNode)</span> -&gt; (bool, int):</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>, <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历右子树</span></span><br><span class="line">            found, val = dfs(r.right)</span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                <span class="keyword">return</span> found, val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历根</span></span><br><span class="line">            <span class="keyword">if</span> self.nk == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, r.val</span><br><span class="line">            self.nk -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历左子树</span></span><br><span class="line">            <span class="keyword">return</span> dfs(r.left)</span><br><span class="line"></span><br><span class="line">        self.nk = k</span><br><span class="line">        _, v = dfs(root)</span><br><span class="line">        <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a>剑指 Offer 55 - I. 二叉树的深度</h2><p>DFS，<code>Depth(root) = 1 + max(Depth(root.left), Depth(root.right))</code></p><h2 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a>剑指 Offer 55 - II. 平衡二叉树</h2><ol><li>解法一：计算并检查每一个节点左右子树的深度，但是这样做会有很多的重复计算。</li><li>解法二：自底向上，同时记录当前子树的深度，从而在计算父节点的深度时，避免重复计算。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -1 表示非平衡，直接返回</span></span><br><span class="line"><span class="comment"># &gt;=0 表示树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(root: TreeNode)</span> -&gt; (int):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = valid(root.left)</span><br><span class="line">    <span class="keyword">if</span> left == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    right = valid(root.right)</span><br><span class="line">    <span class="keyword">if</span> right == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> abs(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> valid(root) != <span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a>剑指 Offer 56 - I. 数组中数字出现的次数</h2><ol><li>如果一个数组中，只有一个数字出现了一次，其他数字都出现了两次，那么可以通过对所有数字进行xor操作，最后得到的就是该数</li><li>如果有两个数字a, b出现了一次，可以想办法将这两个数字划分到两个子数组，这两个子数组除下a, b外，其他都出现了两次，则可直接根据上述规律，xor遍历一遍得到a, b<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        xor_res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">            xor_res = xor_res ^ v</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找xor_res为1的那一位</span></span><br><span class="line">        <span class="comment"># 也就是res1 和 res2 不同的那一位</span></span><br><span class="line">        div = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (xor_res &amp; div) == <span class="number">0</span>:</span><br><span class="line">            div = div &lt;&lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        xor1 = <span class="number">0</span></span><br><span class="line">        xor2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> v &amp; div == <span class="number">0</span>:</span><br><span class="line">                xor1 = xor1 ^ v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                xor2 = xor2 ^ v</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [xor1, xor2]</span><br></pre></td></tr></table></figure></li></ol><h2 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a>剑指 Offer 56 - II. 数组中数字出现的次数 II</h2><ol><li>解法一：遍历统计每个bit 1 出现的次数，最后对 3 取模即可。</li><li>解法二：还有个位运算的解，感觉没必要这么取巧。</li></ol><h2 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a>剑指 Offer 57 - II. 和为s的连续正数序列</h2><p>滑动窗口，<code>[i, j]</code>表示连续子数组的两端，临时sum &lt;&gt; s，j右移扩大窗口，否则 i 左移缩小窗口。</p><h2 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a>剑指 Offer 58 - I. 翻转单词顺序</h2><p>split一下，然后倒序数组，最后拼接。</p><h2 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a>剑指 Offer 58 - II. 左旋转字符串</h2><p>切片操作，不做赘述。</p><h2 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a>剑指 Offer 59 - I. 滑动窗口的最大值</h2><p>这题标记为 easy 过分了。<br>暴力解法就不说了，时间复杂度是 <code>O(k*N)</code>。<br>可以优化一下，使用单调减的辅助队列（类似单调栈），来减少求每个窗口最大值时的遍历情况。复杂度为O(N)，因为辅助队列里的每个数，平均跟新进入队列的数，比较1次。（因为要么直接加入队列，要么，删掉队尾比它小元素，加入队列），被删掉的元素只会被比较 1 次。<br>考虑极端情况，每个数都会加入辅助队列（原数组是递减的），则每次仍只需比较队尾元素和新加入元素 1 次。因此比较了 2N 次<br>PS：单调栈和单调队列，是一个非常有帮助的思路。</p><h2 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a>剑指 Offer 59 - II. 队列的最大值</h2><p>类似 <a href="#剑指-offer-30-包含min函数的栈">剑指 Offer 30. 包含min函数的栈</a>，同样使用单调减的辅助队列。这题也可以称为”包含max函数的队列“。</p><h2 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a>剑指 Offer 60. n个骰子的点数</h2><p>这个题目描述得实在不好理解。</p><blockquote><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p></blockquote><p>不过，写到这里，我发现用文字去描述一个算法思想，确实不太容易。<br>至于这题，举个栗子，比如两个骰子，那么依次输出，抛出骰子的和为 2、3、4、5、6 …的概率。</p><p>首先可知，有 n 个骰子，那么结果范围为 [n, 6*n]，那么利用动态规划思想：</p><ol><li>划分子问题：使用n个骰子抛出 x 的概率，等于使用一个骰子抛出 a 的概率 乘以 n-1 个骰子，抛出 x-a 的概率。一个骰子抛出各个值的概率自然是 1/6</li><li>状态转移公式：dp(n, x) = 1/6 * dp(n, x-a), 其中 a in [1, 6]</li><li>边界条件：dp(1, a) = 1/6，其中 a in [1, 6]</li></ol><h2 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a>剑指 Offer 61. 扑克牌中的顺子</h2><p>除下0之外，数组不能重复。同时计算数组的最小值、最大值。（除 0 以外）<br>判断 <code>max_val - min_val</code> 是否 &lt;= 4。 </p><h2 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a>剑指 Offer 62. 圆圈中最后剩下的数字</h2><p>约瑟夫环，这特么竟然标记为<strong>简单！！！</strong> 说是<code>hard</code>真不算过分。<br>因为输出是最后剩下的数字，也正好是其下标。<br>约瑟夫环的关键在于递推公式:    </p><blockquote><p><code>F(N, M) = (F(N-1, M) + M) % N</code>   </p></blockquote><p>其中，<code>F(N,M)</code>表示 N 个人时，某未被删除的数字的下标。<br>假设 <code>F(N,M) = y</code>，在经过一次删除操作后，y的下标变为了 <code>(y-M)%(N-1)</code>，即 F(N-1, M)，设为 x。<br>（因为 N 个数时，删除 M，会从第 M+1 处重新从 0 计算下标。被删除的 M 处于新数组的队尾，因此不会因为空洞之类的原因，影响新的下标计算。）<br>根据   </p><blockquote><p><code>(y-M)%(N-1)=x</code>   </p></blockquote><p>可推得：</p><blockquote><p> <code>y = (x + M) % N</code>   </p></blockquote><p>其实也好理解，相当于删除的逆过程，x左移M个位置，然后对N取余。</p><p>已知，F(1, M) = 0，因为1个人的时候，剩下数字的下标就是 0，那么可以递推出 F(1, M)，F(2, M) 直到 F(N, M)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int, m: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (m + self.lastRemaining(n<span class="number">-1</span>, m)) % n</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a>剑指 Offer 63. 股票的最大利润</h2><p>这个显然算 easy，却标记为 middle。不再啰嗦。</p><h2 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a>剑指 Offer 64. 求1+2+…+n</h2><p>这个妙在，利用 and / or 操作的执行顺序。已知：</p><blockquote><p>A and B，如果 A 为false，则 B 不会再执行<br>  A or B，如果 A 为true，则 B 不会再执行</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNums</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(n: int)</span>:</span></span><br><span class="line">            _ = n != <span class="number">1</span> <span class="keyword">and</span> self.sumNums(n - <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># _ = n == 1 or self.sumNums(n - 1)</span></span><br><span class="line">            self.res += n</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        sum(n)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a>剑指 Offer 65. 不用加减乘除做加法</h2><p>这个特么又标为easy就离谱，里面的细节一点不少。<br>两个数的相加，在二进制上可以表现为两部分：   </p><ol><li>直接相加，忽略进位：s1 = a ^ b，相同为0，不同为1 </li><li>进位部分：s2 = (a &amp; b) &lt;&lt; 1，同为1的位，要向左进一位</li><li>两部分相加：sum = s1 + s2</li></ol><h2 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a>剑指 Offer 66. 构建乘积数组</h2><p>使用两个辅助数组，分别计算从左到右，以及从右至左的乘积。<br>再优化一下，可以只使用一个辅助数组。</p><h2 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a>剑指 Offer 67. 把字符串转换成整数</h2><p>难点在于检查中间结果是否溢出的条件，两种情况：</p><ol><li><code>res &gt; INT_MAX // 10</code>，此时 res * 10，肯定溢出了   </li><li><code>res == INT_MAX // 10 and cur_num &gt; 7</code>，因为INT_MAX = 2147483647，如果 res 是正数，显然越界；如果 res 是负数，INT_MIN = -2147483648，所以满足这个条件的，只有 INT_MIN 本身。</li></ol><h2 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h2><p>先分析下问题：</p><ol><li>如果 p == root 或 q == root，那么 root 本身就是最近公共祖先</li><li>如果 p &lt; root &lt; q，那root一定是最近公共祖先</li><li>如果不满足 1，那么p和q 一定同时在 root 的左子树或右子树   </li></ol><p>上述root可能是某棵子树的根节点。</p><h2 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a>剑指 Offer 68 - II. 二叉树的最近公共祖先</h2><p>先分析下问题：   </p><ol><li>这是一棵普通二叉树，非搜索二叉树，各节点是无序的</li><li>最近公共祖先的定义不变，对于某节点来说，p/q 分别位于其左右子树；或其为p或q，并且q或p在其子树上；该节点就是最近公共祖先。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 你可能有疑问，不用确定另一个在不再它的子树里吗？无需确定</span></span><br><span class="line">        <span class="comment"># 假如root=p，若q在其子树里，root即为最近公共祖先；</span></span><br><span class="line">        <span class="comment"># 若q不在其子树里，那一定在别的子树里，此时会有left_res和right_res都不为None的时候，也就会返回对应的root</span></span><br><span class="line">        <span class="keyword">if</span> root.val == p.val <span class="keyword">or</span> root.val == q.val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        left_res = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right_res = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="comment"># p, q分别位于root的左右子树，root本身就是解</span></span><br><span class="line">        <span class="keyword">if</span> left_res <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right_res <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 到这里，left_res 和 right_res 一个为None，一个不为None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 情况1：某子树root==p或q，因此返回了自己，此时最近公共祖先，就是该子树的root。</span></span><br><span class="line">        <span class="comment"># 就是left_res或right_res中不为空的那个。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况2：某棵子树上发现了最近公共祖先，将其传递至最上层</span></span><br><span class="line">        <span class="keyword">return</span> left_res <span class="keyword">if</span> left_res <span class="keyword">else</span> right_res</span><br></pre></td></tr></table></figure><h1 id="完结散花"><a href="#完结散花" class="headerlink" title="完结散花 ~"></a>完结散花 <del>~</del></h1><p><img src="/images/jian_zhi_offer.jpg" alt="abc"></p>]]></content>
    
    <summary type="html">
    
      剑指offer 51-75 题，思路简结
    
    </summary>
    
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题目思路简结（二）</title>
    <link href="http://yoursite.com/2020/06/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/06/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-06-22T13:43:53.000Z</published>
    <updated>2020-06-22T13:43:53.000Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ol><li><a href="#剑指-offer-26-树的子结构">剑指 Offer 26. 树的子结构</a></li><li><a href="#剑指-offer-27-二叉树的镜像">剑指 Offer 27. 二叉树的镜像</a></li><li><a href="#剑指-offer-28-对称的二叉树">剑指 Offer 28. 对称的二叉树</a></li><li><a href="#剑指-offer-29-顺时针打印矩阵">剑指 Offer 29. 顺时针打印矩阵</a></li><li><a href="#剑指-offer-30-包含min函数的栈">剑指 Offer 30. 包含min函数的栈</a></li><li><a href="#剑指-offer-31-栈的压入弹出序列">剑指 Offer 31. 栈的压入、弹出序列</a></li><li><a href="#剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</a></li><li><a href="#剑指-offer-32---ii-从上到下打印二叉树-ii">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></li><li><a href="#剑指-offer-32---iii-从上到下打印二叉树-iii">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></li><li><a href="#剑指-offer-33-二叉搜索树的后序遍历序列">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></li><li><a href="#剑指-offer-34-二叉树中和为某一值的路径">剑指 Offer 34. 二叉树中和为某一值的路径</a></li><li><a href="#剑指-offer-35-复杂链表的复制">剑指 Offer 35. 复杂链表的复制</a></li><li><a href="#剑指-offer-36-二叉搜索树与双向链表">剑指 Offer 36. 二叉搜索树与双向链表</a></li><li><a href="#剑指-offer-37-序列化二叉树">剑指 Offer 37. 序列化二叉树</a></li><li><a href="#剑指-offer-38-字符串的排列">剑指 Offer 38. 字符串的排列</a></li><li><a href="#剑指-offer-39-数组中出现次数超过一半的数字">剑指 Offer 39. 数组中出现次数超过一半的数字</a></li><li><a href="#剑指-offer-40-最小的k个数">剑指 Offer 40. 最小的k个数</a></li><li><a href="#剑指-offer-41-数据流中的中位数">剑指 Offer 41. 数据流中的中位数</a></li><li><a href="#剑指-offer-42-连续子数组的最大和">剑指 Offer 42. 连续子数组的最大和</a></li><li><a href="#剑指-offer-43-1n整数中1出现的次数">剑指 Offer 43. 1～n整数中1出现的次数</a></li><li><a href="#剑指-offer-44-数字序列中某一位的数字">剑指 Offer 44. 数字序列中某一位的数字</a></li><li><a href="#剑指-offer-45-把数组排成最小的数">剑指 Offer 45. 把数组排成最小的数</a></li><li><a href="#剑指-offer-46-把数字翻译成字符串">剑指 Offer 46. 把数字翻译成字符串</a></li><li><a href="#剑指-offer-47-礼物的最大价值">剑指 Offer 47. 礼物的最大价值</a></li><li><a href="#剑指-offer-48-最长不含重复字符的子字符串">剑指 Offer 48. 最长不含重复字符的子字符串</a></li><li><a href="#剑指-offer-49-丑数">剑指 Offer 49. 丑数</a></li></ol><!-- /TOC --><h2 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a>剑指 Offer 26. 树的子结构</h2><p>DFS判断各个子树，是否满足子树条件即可。<br><strong>树的结构，天生适合递归。</strong></p><h2 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a>剑指 Offer 27. 二叉树的镜像</h2><p>递归交换左右子树的左右节点。</p><h2 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a>剑指 Offer 28. 对称的二叉树</h2><p>递归判断左右子树的左右节点。</p><h2 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a>剑指 Offer 29. 顺时针打印矩阵</h2><p>像洋葱一样，一层一层剥离打印。注意一些特殊情况，比如矩阵只有一行、一列的情况</p><h2 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a>剑指 Offer 30. 包含min函数的栈</h2><p>关键在于min的复杂度要求O(1)。这里需要用一个单调递减的栈，辅助实现。<br><strong>单调栈、单调队列在处理一些栈、队列最大值、最小值上很有用。</strong></p><h2 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a>剑指 Offer 31. 栈的压入、弹出序列</h2><p>用一个栈去模拟压入、弹出过程，每当pop[0]==stack[-1]时，stack就弹出。<br>如果pushed进栈完后，stack里还有数，则说明序列不对。</p><h2 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a>剑指 Offer 32 - I. 从上到下打印二叉树</h2><p>类似BFS，使用一个队列保存当前level的节点，之后依次遍历。   </p><h2 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a>剑指 Offer 32 - II. 从上到下打印二叉树 II</h2><p>类似 <a href="#剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</a>，每层的结果单独保存即可。</p><h2 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a>剑指 Offer 32 - III. 从上到下打印二叉树 III</h2><p>类似 <a href="#剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</a>，每层的结果单独保存即可。使用一个flag来判断顺序还是逆序。</p><h2 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a>剑指 Offer 33. 二叉搜索树的后序遍历序列</h2><p>根据root节点，划分左右子树，递归判对即可。</p><h2 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a>剑指 Offer 34. 二叉树中和为某一值的路径</h2><p>递归DFS</p><h2 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a>剑指 Offer 35. 复杂链表的复制</h2><p>这题有意思，难得见到一个有意思的链表类的题。思路步骤：   </p><ol><li>复制：对每个节点都复制一个节点，并添加在其后面</li><li>拆分：对复制后的链表进行拆分，由于已知每个节点后面跟的，都是其复制节点，因此只需将复制节点的指向，也指向对应节点的复制节点，即可。</li></ol><h2 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a>剑指 Offer 36. 二叉搜索树与双向链表</h2><p>对二叉搜索树模拟中序遍历，用一个指针记录遍历过程中的pre节点，最后将首尾相连，即可。</p><h2 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a>剑指 Offer 37. 序列化二叉树</h2><p>这题标记为hard，但实际上应该只算得上middle。   </p><ol><li>序列化：类似层次遍历，与 <a href="#剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</a> 相似。   </li><li>反序列化：还是模拟层次遍历的过程</li></ol><h2 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a>剑指 Offer 38. 字符串的排列</h2><p>这种排列组合、枚举类题，都可以用回溯思想来解决。和DFS类似，其实DFS是回溯思想在树、图之类的特殊场景里的一种表现。同DFS，回溯的常见实现方式也是递归。<br><strong>递归的时候，要小心大量的重复计算。（动态规划的递归实现中也存在）</strong> 通常要进行剪枝操作。因此也和动态规划的实现类似，可以使用备忘录法，或自底向上法。自底向上法效率最高，因为常常可以用循环迭代方式实现，减少递归调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 递归回溯，执行时间700ms</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation1</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line"></span><br><span class="line">        res = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            child_res = self.permutation1(s[:i] + s[i + <span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> child_res:</span><br><span class="line">                res.add(s[i] + v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 备忘录，执行时间120ms</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation2</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        seen = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">perm</span><span class="params">(s2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(s2) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s2 <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> seen[s2]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归过程不变</span></span><br><span class="line">            res = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s2)):</span><br><span class="line">                child_res = perm(s2[:i] + s2[i + <span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> child_res:</span><br><span class="line">                    res.add(s2[i:i + <span class="number">1</span>] + v)</span><br><span class="line"></span><br><span class="line">            seen[s2] = list(res)</span><br><span class="line">            <span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line">        sorted_s = <span class="string">''</span>.join(sorted(s))</span><br><span class="line">        <span class="keyword">return</span> perm(sorted_s)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自底向上，执行时间80ms</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation3</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line"></span><br><span class="line">        res = set(s[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s[<span class="number">1</span>:]:</span><br><span class="line">            new_set = set()</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(item)+<span class="number">1</span>):</span><br><span class="line">                    new_item = item[<span class="number">0</span>:i] + c + item[i:]</span><br><span class="line">                    new_set.add(new_item)</span><br><span class="line">            res = new_set</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a>剑指 Offer 39. 数组中出现次数超过一半的数字</h2><p>遍历一遍数组，记录一个数，及其出现次数。</p><h2 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a>剑指 Offer 40. 最小的k个数</h2><p>经典题目，两种解法：</p><ol><li>利用容量为K的大顶堆，遍历一遍即可，比堆顶元素小的入堆，容量超过K时出堆</li><li>利用快排的二分思路，每次可以排除一批不满足条件的数，从而快速缩小查找范围   </li></ol><p>解法的关键思想在于，找最小的k个数，但是这k个数互相是不必排序的，因此尽力减少这部分排序操作。堆就减少了内部各个元素互相排序的操作。同样快排的二分思想，也可以一下子找到最大的m个数，m取决于所选的pivot。但是这m个数只需跟pivot比较，相互之间无需比较。</p><h2 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a>剑指 Offer 41. 数据流中的中位数</h2><p>这个有点妙。   </p><ol><li>使用两个堆，一个使用小顶堆，保存较大的一半数字；一个使用大顶堆，保存较小的一半数字。同时保持两个堆的元素数量相对平衡 <code>0 &lt;= (大堆-小堆) &lt; 1</code>。此时两个堆的堆顶元素，就是数据流中间的两个数。</li><li>在push时，将其和堆顶元素比较选一个堆加入。如果加入后，两个堆失去平衡，则进行调整</li><li>取中位数时，根据两个堆元素数是否相等可知，一共有奇数或偶数个数字。从而根据堆顶元素，计算中位数。</li></ol><h2 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a>剑指 Offer 42. 连续子数组的最大和</h2><p>对于每一个元素，有两个选择，与前一个数字组成子数组，或重新开始计算子数组。<br>记录遍历过程中的最大值。</p><h2 id="剑指-Offer-43-1～n整数中1出现的次数"><a href="#剑指-Offer-43-1～n整数中1出现的次数" class="headerlink" title="剑指 Offer 43. 1～n整数中1出现的次数"></a>剑指 Offer 43. 1～n整数中1出现的次数</h2><p>按个位、十位、百位…考虑，比如：输入314，分析过程如下   </p><ol><li>个位4，&gt;1，高位为31，受此影响，有 32 * 1 = 32 种可能</li><li>十位1，=1，高位为3，低位为4，受此影响，有 3*10 + 5 = 35 种可能</li><li>百位3，&gt;1，高位为0，受此影响，有 1*100 = 100 种可能   </li></ol><p>因此一共 32 + 35 + 100 = 167个。关键在于梳理清各种情况下1的个数。<br>比如十位为1时，那么有01x/11x/21x，以及310~314，这么多种，也就是 3*10+5 = 35种。<br>对于百位，当百位为1时，有1xx这么多种情况，所以就是 1 * 100种。</p><h2 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a>剑指 Offer 44. 数字序列中某一位的数字</h2><p>和 <a href="#剑指-offer-43-1n整数中1出现的次数">剑指 Offer 43. 1～n整数中1出现的次数</a> 类似，关键在于找规律。可以发现:<br>忽略0<br>数字为1位的，从 1 开始，一共 9 个，1 - 9<br>数字为2位的，从 10 开始，一共 90 个，10 - 99<br>数字为3位的，从 100 开始，一共 900 个，100 - 999<br>…<br>依此可确定，第n位所在的区间，在取模可得到具体是哪个数字。大致思想如上，实现细节不再赘述。</p><h2 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a>剑指 Offer 45. 把数组排成最小的数</h2><p>一个取巧的办法，对数组进行自定义排序，从小到大。对于a、b两数的比较规则是，如果ab&gt;ba，则a&gt;b，否则a&lt;b。   </p><h2 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a>剑指 Offer 46. 把数字翻译成字符串</h2><p>按动态规划的方式比较好理解：</p><ol><li>划分子问题：每一位数字，既可以单独表示一个字母，也可以与后面数字组合，共同表示一个字母，如果&lt;26的话。</li><li>状态转移公式：F(s) = F(s[1:]) + F(s[2:])</li><li>边界条件：len(s)&lt;=1时，F(s) = 1; 为什么 s 是空字符串时，F(s)也=1呢，s为空字符串，表示刚好划分完，仅此一种。比如12，F(12) = F(2) + F(“”)，F(“”)表示，12作为一个整体解释。</li></ol><h2 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a>剑指 Offer 47. 礼物的最大价值</h2><p>很基础的动态规划题：<br>按动态规划的方式比较好理解：</p><ol><li>划分子问题：每一个格子可以分为，从上边格子和左边格子过来两种情况</li><li>状态转移公式：dp[i][j] = max(dp[i-1][j]+grid[i][j], dp[i][j-1]+grid[i][j])</li><li>边界条件：第一行和第一列，单独处理   </li></ol><p>另外可以发现，dp[i][j]只和上一行有关，因此为了降低空间复杂度，可以只用一行空间即可。对 M*N 的格子，空间复杂度可以从 O(M * N) 降低至 O(M) 或 O(N)</p><h2 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a>剑指 Offer 48. 最长不含重复字符的子字符串</h2><p>使用两个指针 i, j，分别表示起始和结束。同时记录、更新某字符上次出现的位置。<br>如果 j 指向的当前字符，上次出现的位置 k &gt; i，表示重复出现，则 i 更新为 k + 1。此时得到一个最长不重复子字符串，长度为 j-i。</p><h2 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a>剑指 Offer 49. 丑数</h2><p>下一个丑数为，当前丑数序列 * 2、3、5，得到的丑数中，最小的那个。<br>为了避免重复计算，可以使用三个数，分别记录上一个乘以2、3、5后，就大于最新丑数的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        a, b, c = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 计算下一个丑数</span></span><br><span class="line">            aN, bN, cN = dp[a] * <span class="number">2</span>, dp[b] * <span class="number">3</span>, dp[c] * <span class="number">5</span></span><br><span class="line">            <span class="comment"># 选最小的</span></span><br><span class="line">            next = min(aN, bN, cN)</span><br><span class="line">            dp[i] = next</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> next == aN:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> next == bN:</span><br><span class="line">                b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> next == cN:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      剑指offer 24-50 题，思路简结
    
    </summary>
    
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题目思路简结（一）</title>
    <link href="http://yoursite.com/2020/06/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/06/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-06-22T06:54:13.000Z</published>
    <updated>2020-06-22T06:54:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ol><li><a href="#剑指-offer-03数组中重复的数字">剑指 Offer 03.数组中重复的数字</a></li><li><a href="#剑指-offer-04-二维数组中的查找">剑指 Offer 04. 二维数组中的查找</a></li><li><a href="#剑指-offer-05-替换空格">剑指 Offer 05. 替换空格</a></li><li><a href="#剑指-offer-06-从尾到头打印链表">剑指 Offer 06. 从尾到头打印链表</a></li><li><a href="#剑指-offer-07-重建二叉树">剑指 Offer 07. 重建二叉树</a></li><li><a href="#剑指-offer-09-用两个栈实现队列">剑指 Offer 09. 用两个栈实现队列</a></li><li><a href="#剑指-offer-10--i-斐波那契数列">剑指 Offer 10- I. 斐波那契数列</a></li><li><a href="#剑指-offer-10--ii-青蛙跳台阶问题">剑指 Offer 10- II. 青蛙跳台阶问题</a></li><li><a href="#剑指-offer-11-旋转数组的最小数字">剑指 Offer 11. 旋转数组的最小数字</a></li><li><a href="#剑指-offer-12-矩阵中的路径">剑指 Offer 12. 矩阵中的路径</a></li><li><a href="#剑指-offer-13-机器人的运动范围">剑指 Offer 13. 机器人的运动范围</a></li><li><a href="#剑指-offer-14--i-剪绳子">剑指 Offer 14- I. 剪绳子</a></li><li><a href="#剑指-offer-14--ii-剪绳子-ii">剑指 Offer 14- II. 剪绳子 II</a></li><li><a href="#剑指-offer-15-二进制中1的个数">剑指 Offer 15. 二进制中1的个数</a></li><li><a href="#剑指-offer-16-数值的整数次方">剑指 Offer 16. 数值的整数次方</a></li><li><a href="#剑指-offer-17-打印从1到最大的n位数">剑指 Offer 17. 打印从1到最大的n位数</a></li><li><a href="#剑指-offer-18-删除链表的节点">剑指 Offer 18. 删除链表的节点</a></li><li><a href="#剑指-offer-19-正则表达式匹配">剑指 Offer 19. 正则表达式匹配</a></li><li><a href="#剑指-offer-20-表示数值的字符串">剑指 Offer 20. 表示数值的字符串</a></li><li><a href="#剑指-offer-21-调整数组顺序使奇数位于偶数前面">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></li><li><a href="#剑指-offer-22-链表中倒数第k个节点">剑指 Offer 22. 链表中倒数第k个节点</a></li><li><a href="#剑指-offer-24-反转链表">剑指 Offer 24. 反转链表</a></li><li><a href="#剑指-offer-25-合并两个排序的链表">剑指 Offer 25. 合并两个排序的链表</a></li></ol><!-- /TOC --><h2 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03.数组中重复的数字"></a>剑指 Offer 03.数组中重复的数字</h2><p>直接使用hash即可，高级一点的使用bitmap也可</p><h2 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h2><p>关键在于，利用规律缩小查找范围。   </p><ol><li>如果target &lt; 当前的数，那么它就不可能在target同一行的左边</li><li>每一列都按照从上到下递增的顺序排序：那么如果target &gt; 当前的数，那么它就不可能在target同一列的上面  </li></ol><p>从右上角开始找，一点一点缩小范围。</p><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><ol><li>如果用python/java/golang之类的，可以直接拼接字符串。动态分配内存。   </li><li>如果用c/c++，就需要预分配内存，因此需要先遍历一遍，计算有多少个空格，从而计算结果字符串所需内存大小。</li></ol><h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h2><ol><li>解法一：先遍历，再对结果数组反转</li><li>解法二：使用栈暂存节点，然后弹出栈 </li></ol><h2 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a>剑指 Offer 07. 重建二叉树</h2><p>关键点：</p><ol><li>中序遍历的第一个节点，是当前节点的root；但是没法区分剩余节点，哪些是左、右子树</li><li>根据root，可以把前序遍历，分为左右子树两部分；借此得知左右子树的节点数量，也就能把中序遍历剩余节点分开</li><li>对中序遍历拆分的左右子树，递归求解</li></ol><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h2><p>关键点：</p><ol><li>两个栈，一个是input栈，一个是output栈，分别只负责input和output</li><li>output没了，就从input里转移到output   </li></ol><p>时间复杂度，O(1)；空间复杂度，O(n)</p><h2 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h2><p>递归、迭代解法，不再赘述。<br>值得一提的是，对于递归类题目，有两个关键点：</p><ol><li>递归子问题</li><li>递归终止条件，这个不能忘   </li></ol><p>尤其是二叉树类的问题，天生合适递归。把一个二叉树的问题，转换为，分别针对左右子树的两个子问题。</p><h2 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a>剑指 Offer 10- II. 青蛙跳台阶问题</h2><p>同 <a href="#剑指-offer-10--i-斐波那契数列">剑指 Offer 10- I. 斐波那契数列</a> 斐波那契数列。</p><h2 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a>剑指 Offer 11. 旋转数组的最小数字</h2><p>二分法，确定min_index在[left, mid]，还是在[mid, right]之间。注意下极端条件，比如：翻转0个的情况；所有数都相等的情况；最后剩余两个数的情况；mid和边界相等的情况等等</p><h2 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a>剑指 Offer 12. 矩阵中的路径</h2><p>DFS</p><h2 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a>剑指 Offer 13. 机器人的运动范围</h2><p>BFS，当然DFS也可以，不过BFS最合适，相当于一圈一圈地扩展范围</p><h2 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a>剑指 Offer 14- I. 剪绳子</h2><p>简单的动态规划，顺带提一下动态规划的三个关键点：</p><ol><li>划分子问题：一个大问题可以拆分为多个小问题，并且在大问题是最优解时，</li><li>状态转移公式</li><li>边界条件   </li></ol><p>是不是很像递归，因为动态规划一个最简单的实现方式就是递归。对于该题，三个关键点分别是：</p><ol><li>划分子问题：长度为n的绳子，最大乘积，等于将其分一部分、两部分、多部分的最大值。</li><li>状态转移公式：F(n) = max( (n-i) * F[i] for i in range(1, n))</li><li>边界条件：F(0) = 1; F(1) = 1   </li></ol><p>另外，由于该题要求至少分两段，因此需要对长度为最长时，稍微做一点特殊处理。</p><p>如果是递归实现，是会提示超时的，因为其中存在很多重复的计算。可以用递归的另外两种实现方式：备忘录法，自底向上法。</p><p>还有一种解法是根据数学规律，将n分为多个3。这种解法不具通用性，就不介绍了。</p><h2 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a>剑指 Offer 14- II. 剪绳子 II</h2><p>在 <a href="#剑指-offer-14--i-剪绳子">剑指 Offer 14- I. 剪绳子</a> 基础上，多了大数，就直接使用long类型，然后取模吧。</p><h2 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a>剑指 Offer 15. 二进制中1的个数</h2><p>经典位运算题。n的每一位与 1 做 与操作，直到n变为0。</p><h2 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a>剑指 Offer 16. 数值的整数次方</h2><p>关键点，利用二分思想：   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pow(x, n) = pow(x, n//<span class="number">2</span>) ** <span class="number">2</span>  <span class="comment"># n为偶数   </span></span><br><span class="line">pow(x, n) = pow(x, n//<span class="number">2</span>) ** <span class="number">2</span> * x  <span class="comment"># n为奇数</span></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a>剑指 Offer 17. 打印从1到最大的n位数</h2><p>最大的n位数，是 pow(10, n)-1，遍历即可。<br>小心大数越界，如果是面试。</p><h2 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h2><p>不再赘述。<br>值得一提：链表类问题，可以增加一个头结点dummy_head，这样可以使边界情况，处理起来方便很多。</p><h2 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a>剑指 Offer 19. 正则表达式匹配</h2><p>动态规划：（主串S, 模式串T）   </p><ol><li><p>划分子问题：如果S和T匹配，那么S和T的子串也匹配</p></li><li><p>状态转移公式：<br>为了避免每次都要检查，后一个字符串是否是”*”，从后往前遍历。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. T[i] 是普通字符</span><br><span class="line">    F(S, T) &#x3D; S[i] &#x3D;&#x3D; T[i] &amp;&amp; F(S[:-1], T[:-1])</span><br><span class="line"></span><br><span class="line">2. T[i] &#x3D;&#x3D; &#39;.&#39;，可以匹配任何字符</span><br><span class="line">    F(S, T) &#x3D; F(S[:-1], T[:-1])</span><br><span class="line"></span><br><span class="line">3. T[i] &#x3D;&#x3D; &#39;*&#39;，*前面的字符可以重复0次或多次</span><br><span class="line">    </span><br><span class="line">    3.1 S&#x3D;&#x3D;&quot;&quot;, 说明*前面的字符重复0次</span><br><span class="line">        F(S, T) &#x3D; F(S, T[:-2])</span><br><span class="line"></span><br><span class="line">    3.2 T[-2] &#x3D;&#x3D; &#39;.&#39; 或 S[-1] &#x3D;&#x3D; T[-2]，前一个字符能匹配上，则需考虑匹配0次、和多次的情况</span><br><span class="line">        F[S, T] &#x3D; F(S, T[:-2]) || F(S[:-1], T)   </span><br><span class="line"></span><br><span class="line">    3.3 S[-1] !&#x3D; T[-2]，前一个字符不匹配，相当于匹配了0次</span><br><span class="line">        F(S, T) &#x3D; F(S, T[:-2])</span><br></pre></td></tr></table></figure></li><li><p>边界条件:<br>边界条件，就是S、T一直递归匹配，直到某一个变为了空字符串</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. S &#x3D;&#x3D; &quot;&quot; &amp;&amp; T &#x3D;&#x3D; &quot;&quot;，return True</span><br><span class="line"></span><br><span class="line">2. S &#x3D;&#x3D; &quot;&quot; &amp;&amp; T !&#x3D; &quot;&quot;, 需要继续匹配，比如 S&#x3D;”“， T&#x3D;&quot;a*&quot;，是匹配的</span><br><span class="line"></span><br><span class="line">3. S !&#x3D; &quot;&quot; &amp;&amp; T &#x3D;&#x3D; &quot;&quot;, return False</span><br></pre></td></tr></table></figure></li></ol><h2 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a>剑指 Offer 20. 表示数值的字符串</h2><p>非常典型的一道<code>有限状态机</code>题，重点在于划分不同的状态，怕错不怕重复。状态之间的转移相对容易。</p><h2 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h2><p>两个指针，pre指针从头开始遍历，post指针指向尾。每次pre指向一个偶数，就将其与post交换，直到两指针相遇。</p><h2 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h2><p>快慢指针，不做赘述。</p><h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h2><p>三个指针，循环遍历即可。注意边界条件。</p><h2 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a>剑指 Offer 25. 合并两个排序的链表</h2><p>添加一个dummy头结点，然后对两个链表，执行类似一个归并排序的操作。</p><p><img src="/images/jian_zhi_offer.jpg" alt="CSRF示意图"></p>]]></content>
    
    <summary type="html">
    
      剑指offer 1-23 题，思路简结
    
    </summary>
    
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>人生的一些大道理</title>
    <link href="http://yoursite.com/2020/06/11/%E4%BA%BA%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%A7%E9%81%93%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/11/%E4%BA%BA%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%A7%E9%81%93%E7%90%86/</id>
    <published>2020-06-11T08:25:13.000Z</published>
    <updated>2020-06-11T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然明明没啥资格去说人生这种大事，毕竟我也是第一次经历，并且只经历了一种人生。<br>然鹅，还是想闲扯几句。也是看李笑来老师的书，说一下自己的想法。</p><h3 id="问题1-工作，还是睡懒觉？"><a href="#问题1-工作，还是睡懒觉？" class="headerlink" title="问题1. 工作，还是睡懒觉？"></a>问题1. 工作，还是睡懒觉？</h3><p>首先，<strong>单独就辛苦本身，不值得。</strong> 如果你家财万贯，衣食无忧，房车不缺，干嘛非得让自己辛苦？即使你没有大富大贵，但对目前的生活还挺满意，也不想着去追求更加丰富、昂贵的东西啦，更加崇高的地位啦，那也没必要辛辛苦苦。这两种情况，自己对什么有兴趣，就去做什么，这就挺好的呗~简直是我的理想生活啊！</p><p>然鹅，无论出于什么原因，<strong>如果你想追求更好的，那辛苦就是值得的。</strong></p><h3 id="问题2-生活是否公平？"><a href="#问题2-生活是否公平？" class="headerlink" title="问题2. 生活是否公平？"></a>问题2. 生活是否公平？</h3><p>上帝是不公平的，付出了不一定有回报。<br>上帝是公平的，不付出，就一定没有回报。   </p><p>哪怕买彩票，也得多买几次，才更容易中奖不是？</p><p>人很少会后悔做了哪些事，但是常常后悔没做哪些事儿。   </p><p>另外，高考真的是人生最公平、公正的一次。而且大学这个烙印将陪伴你终身。高中要好好学习啊，弟弟妹妹们。大学就无所谓，想做其他事就去做，别挂科就行。</p><h3 id="问题3-你的，还是我的？"><a href="#问题3-你的，还是我的？" class="headerlink" title="问题3. 你的，还是我的？"></a>问题3. 你的，还是我的？</h3><p>街上碰到一个苹果，两个人同时看到了，这个苹果该属于谁呢？有人离得近，有人离得远，有人走过去，有人跑过去。不管怎样，先到达的那个有苹果吃。<br>同样，有人生来就离苹果近，有人生来跑得快，有人毅力强能坚持。谁会是最后的赢家？<br>我们不知道这个距离有多远，但是人生近百年，不是一场百米赛跑，而是一个马拉松。<br>苹果，强者得之。<br>所以，是我的。[doge]   </p><p><img src="/images/kobe.jpeg" alt="">   </p><p><strong>Respect ！</strong></p>]]></content>
    
    <summary type="html">
    
      李笑来传话筒。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从CAS到无锁队列.md</title>
    <link href="http://yoursite.com/2020/06/03/%E4%BB%8ECAS%E5%88%B0%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/03/%E4%BB%8ECAS%E5%88%B0%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</id>
    <published>2020-06-03T09:24:15.000Z</published>
    <updated>2020-06-03T09:24:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无锁算法"><a href="#无锁算法" class="headerlink" title="无锁算法"></a>无锁算法</h2><p>多个线程读写同一内存，如何做到不加锁呢？其实没有那么高大上的算法在里面，实现无锁的前提是，硬件需支持”读取-更新-写入“的原子操作，比如 Test and Set, Fetch and Add, Compare and Swap等。<br>以Compare and Swap，也就是CAS为例，可以实现很多无锁的数据结构，无锁队列，无锁树，区别在于需要几次的CAS。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p><code>bool CAS(type* addr, type val_old, type val_new)</code><br>如果 addr 的值等于 val_old，就把它设置为 val_new，设置成功返回true，失败返回false。<strong>这个比较并赋值的操作，是一个原子操作。</strong></p><h2 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h2><p>我们使用一个单向链表，作为无锁队列的基础数据结构。利用CAS的原子性，来保证在push/pop，也就是在链表尾/头添加、删除节点时，不会出现多线程互相覆盖的问题。</p><p>直接看代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很久没写C/CPP，语法细节忘了不少，忽略忽略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    node* tail  <span class="comment">// 尾指针</span></span><br><span class="line">    node* head  <span class="comment">// 头指针</span></span><br><span class="line">&#125;* Q</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Q是队列，data是待push的节点</span></span><br><span class="line">Push(Q, data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> </span><br><span class="line">    &#123;</span><br><span class="line">        p = Q-&gt;tail;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">CAS</span><span class="params">(p-&gt;next, <span class="literal">NULL</span>, data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果此时p还是Q的tail，才能设置成功</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新Q的tail，如果此时tail还是p，才能设置成功。</span></span><br><span class="line">    <span class="comment">// 此时不用担心失败，因为如果此处不更新tail，其他线程拿到的总是旧的tail，</span></span><br><span class="line">    <span class="comment">// 其他线程在while循环中的CAS，会发现p-&gt;next!=NULL，就会失败, 一直处于while循环中</span></span><br><span class="line">    CAS(Q-&gt;tail, p, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Pop(Q)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> </span><br><span class="line">    &#123;</span><br><span class="line">        p = Q-&gt;head</span><br><span class="line">        <span class="keyword">if</span> CAS(Q-&gt;head, p, p-&gt;next) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于CAS会直接用新值覆盖旧值，为了保存旧值，所以每次都会先把旧值取出来。然后在设新值时，要判断旧值是否发生了变化。<br>那么以上实现有什么问题没？</p><ol><li><p>问题1，死循环<br>考虑一些意外的情况。对于Push，如果线程第一个CAS执行成功，在执行第二个CAS时宕掉。此时 tail 未更新，其他线程会发现tail.next总是不为空，因此就会陷入while死循环。</p></li><li><p>问题2，<strong>ABA问题</strong><br>比如，一个线程按序执行了 pop -&gt; push操作，而push的节点，恰巧复用了被pop节点同一块内存。因为此链表例子中，CAS比较的是内存地址，所以校验通过。而里面的值其实是发生了变化的，如果不校验里面的值，可能会认为节点未被改动。</p></li></ol><p>这两个问题如何解决呢？   </p><ol><li>死循环问题</li></ol><ul><li>关键：tail节点未更新，导致CAS(p-&gt;next, NULL, data) 总是失败，因此可以让每个线程发现这个问题后，自己去更新tail节点。</li></ul><ol start="2"><li>ABA问题   </li></ol><ul><li>节点增加计数器，每一次更新。计数的增减操作也需要原子化。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无锁数据结构的大致思想就是这样。<br>借助CAS，一个极端的想法，所有程序都可以做成无锁的。只需要对任何一个变量的读写，都使用CAS操作，失败则从头开始。此时，虽然实现了无锁，但是效率却是降低的，因此，无锁也有它的适用场景 — <strong>读多写少</strong>。因此此时CAS的冲突率比较小。<br>与CAS比较像的一个机制，是自旋锁。自旋锁总是在尝试<strong>加锁</strong>，而CAS总是在尝试<strong>比较-修改</strong>，都算是<strong>忙等</strong>机制。</p>]]></content>
    
    <summary type="html">
    
      从无锁思想到CAS，再到具体实现，以无锁队列为例。
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法思想" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>PathEscape与QueryEscape</title>
    <link href="http://yoursite.com/2020/05/29/PathEscape%E4%B8%8EQueryEscape/"/>
    <id>http://yoursite.com/2020/05/29/PathEscape%E4%B8%8EQueryEscape/</id>
    <published>2020-05-29T04:56:52.000Z</published>
    <updated>2020-05-29T04:56:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在给client种cookie时，发现个问题，种进去的加密cookie，解密时总报错。<br>原因是：golang中，对一个字符串做url转义有两个方法，<code>url.PathEscape()</code>和<code>url.QueryEscape</code>。但是两个方法的行为有些区别。两者混用导致，编码和解码后，和原始字符串不一致。</p><h3 id="1-举个例子，直接对比下效果"><a href="#1-举个例子，直接对比下效果" class="headerlink" title="1. 举个例子，直接对比下效果"></a>1. 举个例子，直接对比下效果</h3><p>以 + 和 空格 这两个字符为例。   </p><table><thead><tr><th align="center">待转义字符</th><th align="center">PathEscape</th><th align="center">QueryEscape</th><th align="center">PathUnEscape</th><th align="center">QueryUnEscape</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">+</td><td align="center">%2B</td><td align="center">+</td><td align="center">空格</td></tr><tr><td align="center">空格</td><td align="center">%20</td><td align="center">+</td><td align="center">空格</td><td align="center">空格</td></tr></tbody></table><h3 id="2-具体功能"><a href="#2-具体功能" class="headerlink" title="2. 具体功能"></a>2. 具体功能</h3><h4 id="2-1-PathEscape"><a href="#2-1-PathEscape" class="headerlink" title="2.1 PathEscape"></a>2.1 PathEscape</h4><p>对特殊字符串进行转义，以便其可以作为url路径的一部分。就是URL地址两个 / 之间的部分</p><h4 id="2-2-QueryEscape"><a href="#2-2-QueryEscape" class="headerlink" title="2.2 QueryEscape"></a>2.2 QueryEscape</h4><p>对特殊字符串进行转义，以便其可以作为url query的参数，也就是 ？后面那一串kv。</p><h4 id="2-3-对比"><a href="#2-3-对比" class="headerlink" title="2.3 对比"></a>2.3 对比</h4><ol><li><p>两者的共同点在于：都会将一些特殊字符，转义为<code>%AB</code>的形式。特殊字符的定义为，除<code>a-z，A-Z，0-9，- _ ~ · , / ; ?</code> 的字符。</p></li><li><p>不同点在于：对于一些特殊字符，转义行为不同。</p></li></ol><table><thead><tr><th align="center">字符</th><th align="center">PathEscpae</th><th align="center">QueryEscape</th></tr></thead><tbody><tr><td align="center">$</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">&amp;</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">+</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">:</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">=</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">@</td><td align="center">Y</td><td align="center">N</td></tr></tbody></table><p>具体的可参考RFC文档（URI、URL的两篇）和Golang的源码。（Golang源码更简单直接）</p><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><p>其他语言似乎没分得那么清，具体实现上也有一些区别，比如python/javascript，encode行为就和golang的不一致。总之，同一语言，如golang，QueryEscape编码后，一定要配合QueryUnEscape使用。</p><p>一些细节也不同，比如JS里的encodeURI和encodeURIComponent。可以理解为，encodeURI，是把参数当做一个完整的URI在编码，而encodeURIComponent是把参数当做URI的一个segment。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS里</span></span><br><span class="line"><span class="built_in">encodeURI</span>(<span class="string">"12+34 56"</span>)</span><br><span class="line">output: <span class="string">"12+34%2056"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">"12+34 56"</span>)</span><br><span class="line">output: <span class="string">"12%2B34%2056"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"http://www.ruanyifeng.com/blog/2010/02/url_encoding.html"</span></span><br><span class="line"><span class="built_in">encodeURI</span>(a)</span><br><span class="line">output: <span class="string">"http://www.ruanyifeng.com/blog/2010/02/url_encoding.html"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">encodeURIComponent</span>(a)</span><br><span class="line">output: <span class="string">"http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2010%2F02%2Furl_encoding.html"</span></span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol><li><a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/02/url_encoding.html</a></li><li><a href="https://tools.ietf.org/html/rfc1738" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1738</a></li><li><a href="https://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc3986</a></li></ol>]]></content>
    
    <summary type="html">
    
      搞懂PathEscape与QeuryEscape区别
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>关于工作的一些想法.md</title>
    <link href="http://yoursite.com/2020/05/28/%E5%85%B3%E4%BA%8E%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/28/%E5%85%B3%E4%BA%8E%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</id>
    <published>2020-05-28T06:36:40.000Z</published>
    <updated>2020-05-28T06:36:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- 0. 工作的目的1. 浮于表面，不用思考2. 重复性，还是不用思考 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- 0. 工作的目的

1. 浮于表面，不用思考

2. 重复性，还是不用思考 --&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>常见web安全总结</title>
    <link href="http://yoursite.com/2020/05/25/%E5%B8%B8%E8%A7%81web%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/05/25/%E5%B8%B8%E8%A7%81web%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-25T08:20:55.000Z</published>
    <updated>2020-05-25T08:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XSS，跨站脚本攻击"><a href="#XSS，跨站脚本攻击" class="headerlink" title="XSS，跨站脚本攻击"></a>XSS，跨站脚本攻击</h3><p>XSS的根本原因是，前端页面被嵌入一些恶意代码，这些恶意代码可能通过不同途径，注入进来。根据不同注入途径（或着说方式），可以分为反射型、持久型。</p><ol><li>反射型XSS   </li></ol><ul><li>恶意伪造url -&gt; 骗取用户点击 -&gt; 页面从url取参数进行渲染。从而参数里的恶意代码被执行。</li><li>案例：微博hellosamy事件</li></ul><ol start="2"><li>持久性XSS   </li></ol><ul><li>在留言板、评论等场景提交恶意代码 -&gt; 后台未经处理，直接保存了前端提交的数据，-&gt; 再次访问或其他人访问时，前端展示相关内容，又把这些数据取出来进行渲染，从而恶意代码被执行。  </li><li>案例：微信公众号XSS事件</li></ul><ol start="3"><li><p>应对：</p><ol><li>用户提交的数据，入库前预处理，很多xssfilter</li><li>前端拼接Html时，也要做充分转义</li><li>为了防止cookie盗用，重要cookie设置http-only为true</li></ol></li><li><p>参考   </p><blockquote><p><code>https://tech.meituan.com/2018/09/27/fe-security.html</code></p></blockquote></li></ol><h3 id="CSRF，跨站请求伪造（英語：Cross-site-request-forgery）"><a href="#CSRF，跨站请求伪造（英語：Cross-site-request-forgery）" class="headerlink" title="CSRF，跨站请求伪造（英語：Cross-site request forgery）"></a>CSRF，跨站请求伪造（英語：Cross-site request forgery）</h3><p>本质是浏览器在发起请求时，会自动带上对应域名下的cookie。该特性可能导致，用户在访问恶意网站时，在用户不知不觉的情况下，触发一些携带了用户身份信息（cookie）的请求。如下图所示：<br><img src="/images/csrf.jpg" alt="CSRF示意图"></p><blockquote><ol><li>银行网站A，它以GET请求来完成银行转账的操作，如：<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a></li><li>危险网站B，它里面有一段HTML的代码如下：<pre><code class="html">　　<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">http://www.mybank.com/Transfer.php?toBankId</span>=<span class="string">11&amp;money</span>=<span class="string">1000</span>&gt;</span></code></pre></li><li>首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……</li></ol></blockquote><p>在访问危险网站B的之前，你已经登录了银行网站A，而B中的img以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取src指向的资源，结果银行网站服务器收到请求后，判断身份通过，所以就立刻进行转账操作……</p><p>该例子里，一方面是由于用户上了小网站，另一方面，不应该用GET请求去更新资源（更改账户）。因为像src/script等标签都是默认用GET获取资源，如果再对前端熟悉一些的，可能会想到jsonp，就是利用script标签实现的。<br>很多邮箱图片默认不展示，CSRF也是原因之一。当然还有很多其他的风险，这个可以单开一篇，开开脑洞。</p><ol><li><p>vs 跨域？<br>很多人会有疑问，浏览器不是有跨域限制吗，为什么还会出现在A页面，访问B服务器的情况。对于跨域请求，<strong>浏览器还是会正常发出</strong>，收到response后，会判断源和当前页面的源是否是属于同源，如果不属于，则需要根据<code>access-control-allow-origin</code>等header，判断server端是否允许跨域。   </p></li><li><p>应对<br>主要通过两个关键点：   </p><ol><li>虽然A网站可以向B服务器发请求，但是由于跨域限制，没法处理对应的response。因此一些更新资源的操作，最好用POST，更好的是使用restful风格。另一方面，也可以增加二次确认，比如引入验证码，实际上相当于一个动态的token。</li><li>由于正规的浏览器，对cookie访问，也要求同源。因此可以再query里增加一些cookie里才有的信息，在服务端校验query和cookie里对应的参数，如果不一致则为恶意。   </li></ol></li></ol><p>其他的方法，还有增加referer，但是有的时候请求不带referer，比如非http协议页面发出的请求（ftp之类的）、https页面发出的http请求等，因此该方法有一定的漏洞。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>关键点：<br>    1. 不要相信请求携带的参数，不要直接拿过来拼接SQL语句。<br>SQL注入的防范很成熟，使用prepare statement即可，常用的client lib里都会实现。但是表名不支持参数化，因此表名还是得使用代码拼接的方式。这就要求表名不能是前端输入的，或者增加表名白名单校验。   </p><blockquote><p>从一条sql执行过程来说，编译 -&gt; 执行。一般情况是连带参数，一起编译，就会出现注入情况。<br>  使用参数化查询的形式，会提前对模板进行预编译，而每个?占位的参数，只会被数据库当做一个完整的参数处理。</p></blockquote>]]></content>
    
    <summary type="html">
    
      总结常见的几种Web安全问题，包括XSS、CSRF、SQL注入。
    
    </summary>
    
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL知识点</title>
    <link href="http://yoursite.com/2020/05/20/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2020/05/20/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-05-20T03:09:35.000Z</published>
    <updated>2020-05-20T03:09:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h2><table><thead><tr><th>范式</th><th>描述</th><th>反例</th></tr></thead><tbody><tr><td>第一范式</td><td>每个字段都是原子的，不能再分解</td><td>某个字段是json串</td></tr><tr><td>第二范式</td><td>1. 表必须有主键；2. 非主属性，必须完全依赖主键，而不能只依赖主键的一部分字段。</td><td>好友关系表，关注人ID+被关注人ID作为主键，还存储了关注人的头像，这个只依赖于主键的一个字段。</td></tr><tr><td>第三范式</td><td>非主属性，直接依赖主键，而非间接依赖。</td><td>员工表，有部门ID和部门名称等，部门名称依赖部门ID，而不是员工ID，不应在员工表中。</td></tr></tbody></table><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>比如电商订单表，有三个查询纬度：订单ID，用户ID，商户ID。</p><ol><li>建立主纬度和辅助纬度之间的一个映射表<br>比如，以订单ID拆分，那么要保存用户ID-&gt;订单ID和商户ID-&gt;订单ID的映射表。然而问题是：<ol><li>映射表本身也要分表</li><li>每个订单，要写入多个库，属于分布式事务问题。通常会由后台任务，定时对比，保证多库表最终一致。</li></ol></li><li>业务双写<br>存多份数据，但是拆分纬度不一样。一套按用户ID划分，一套按商户号划分。同样存在写入多个库的分布式事务问题。</li><li>异步双写<br>还是多份数据，业务单写一份，然后通过监听binlog，同步到其他表上</li><li>多个纬度统一到一个纬度<br>比如把订单ID和用户ID统一成一个维度，然后把用户ID作为订单ID的一部分。这样，订单ID中就包含了用户ID的信息，然后按照用户ID分库，当按订单ID查询的时候，提取出用户ID，再按用户ID查询。   </li></ol><p><strong>总之就是，拆分依据的维度，要同时在多个原始ID中提现</strong></p><h2 id="分库分表后的Join问题"><a href="#分库分表后的Join问题" class="headerlink" title="分库分表后的Join问题"></a>分库分表后的Join问题</h2><ol><li>join拆分为多个单表查询，在应用层代码里做join处理</li><li>增加宽表，提前join好</li><li>利用搜索引擎，比如ES，将DB数据导入ES中</li></ol><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><ol><li>最好是优化业务，避免跨库事务</li><li>如果无法避免，参考笔记：分布式事务一致性</li></ol><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>相比hash索引，以及类似结构的KV缓存或数据库，有以下特性</p><ol><li>范围查询</li><li>前缀匹配，模糊查询</li><li>排序和分页</li></ol><h3 id="2-物理结构"><a href="#2-物理结构" class="headerlink" title="2. 物理结构"></a>2. 物理结构</h3><ol><li>磁盘属于块设备，innoDB读写磁盘，是以page为基本单位，page默认大小是16KB，每次I/O都是16KB的整数倍。   </li><li>innoDB为每个Page赋予一个32位的全局编号，因此innoDB的存储上限是<strong>64T</strong> (2^32 * 16KB)。<br>如果用来装非叶子节点，假如key是64位整数，也就是8字节，加上其他字段，按16字节算，一个page可以装1000个key。基于此估算，一个三层的B+树，可以存储的数据量：<ol><li>第一层：根节点，一个page，1000个key。16KB内存，对应1000个子节点</li><li>第二层：1000个节点，每个节点一个page，每个page又可以有1000个子节点。16MB内存，对应1000 * 1000个子节点</li><li>第三层：1000 * 1000个节点，每个节点一个page。那么该表的最大容量是：1000 * 1000 * 16KB = 16GB。<strong>只需要16MB的内存索引，只需要一次I/O读取叶子节点</strong>    </li></ol></li><li>叶子page内部，以单向链表的方式，存储一条条的记录</li><li>非主键索引，索引树叶子节点存的是主键的value。</li></ol><h2 id="事务与锁"><a href="#事务与锁" class="headerlink" title="事务与锁"></a>事务与锁</h2><h3 id="1-隔离级别"><a href="#1-隔离级别" class="headerlink" title="1. 隔离级别"></a>1. 隔离级别</h3><table><thead><tr><th>隔离级别</th><th>解决问题</th></tr></thead><tbody><tr><td>Read Uncommited</td><td></td></tr><tr><td>Read commited</td><td>解决脏读</td></tr><tr><td>Repeatable Read</td><td>解决幻读（通过间隙锁），innoDB默认级别。MVCC需要结合行锁，实现当前读，解决update时的覆盖问题。</td></tr><tr><td>Serialization</td><td></td></tr></tbody></table><h3 id="2-死锁检测"><a href="#2-死锁检测" class="headerlink" title="2. 死锁检测"></a>2. 死锁检测</h3><ol><li>判断一个有向图是否存在环，dfs、拓扑排序</li><li>死锁的发生，与代码有关，也与事务隔离级别有关，因为隔离级别会影响加锁机制。</li><li>复杂度是O(N)</li></ol><h3 id="3-innoDB的MVCC实现"><a href="#3-innoDB的MVCC实现" class="headerlink" title="3. innoDB的MVCC实现"></a>3. innoDB的MVCC实现</h3><ol><li>每一行都有两个隐藏列，<strong>最近修改的事务ID</strong> + <strong>undolog里回滚段指针（便于回滚）</strong></li><li>一致性视图，{low_trx_id, up_trx_id, trx_ids}   <ul><li>low_trx_id: 当前事务链表，最小的事务id</li><li>up_trx_id:  当前事务链表，最大的事务id</li><li>trx_ids: 正在执行的事务的id集合<br>通过比较当前事务id，与以上三个变量的关系，确定某个版本数据，是否对当前事务可见。</li></ul></li></ol><h3 id="4-事务实现"><a href="#4-事务实现" class="headerlink" title="4. 事务实现"></a>4. 事务实现</h3><h4 id="1-WAL-Write-Ahead-Log"><a href="#1-WAL-Write-Ahead-Log" class="headerlink" title="1. WAL, Write-Ahead Log"></a>1. WAL, Write-Ahead Log</h4><p>内存操作数据 + write-ahead log</p><h4 id="2-Redo-Log的逻辑与物理结构"><a href="#2-Redo-Log的逻辑与物理结构" class="headerlink" title="2. Redo Log的逻辑与物理结构"></a>2. Redo Log的逻辑与物理结构</h4><ol><li>redo log 物理组成结构<ol><li>一个逻辑事务 包含 多个物理事务mtr，Mini Transaction</li><li>每个mtr对应一个LSN</li><li>一个LSN对应若干个连续的block</li><li>这些block，最终组成了 redo log   <blockquote><p>综上，一个事务在redo log里，可能有多个LSN，这些LSN自己是连续的，但是多个LSN不一定是连续的。</p></blockquote></li></ol></li><li>redo log 日志内容格式<ol><li>先以page为单位记录日志</li><li>在每个page里面再采用物理记法<blockquote><p>比如 (page id, record offset, (field1, value1)..(fieldi, valuei)…)   </p></blockquote></li></ol></li><li>Aries恢复算法<ol><li>分析阶段<br>从上一个checkpoint开始，开始分析哪些事务执行完了，未刷写page；哪些事务执行了一半，需要回滚。checkpoint机制，可以加快分析速度</li><li>redo阶段<br>对已经commit的事务，执行redolog，刷写page。redolog是幂等的，重复执行没关系。</li><li>undo阶段<br>对于未commit的事务，执行undolog，回滚</li></ol></li><li>其他<ol><li>每个page上记录了，上次修改的LSN，因此恢复时，如果redolog里的lsn&lt;page lsn，说明不用重写了。</li><li>redolog保证的是事务的持久性，写入成功，则不会丢失</li></ol></li></ol><h4 id="3-Undo-log"><a href="#3-Undo-log" class="headerlink" title="3. Undo log"></a>3. Undo log</h4><ol><li>redolog按LSN的顺序，而undolog没有顺序，多个事务并行写。每条日志除下记录主键ID和数据外，还有两个字段：修改记录的事务ID和回滚指针，用来串联所有历史版本，就是MVCC的两个隐藏列。</li><li>undo log 只在commit的过程中有用，一旦事务commit了，就可以删掉undo log</li><li>通俗一点，修改行前，先把行拷贝一份出来，这些历史版本形成一个链表。</li></ol><h2 id="各种锁"><a href="#各种锁" class="headerlink" title="各种锁"></a>各种锁</h2><ol><li>有不同的划分标准，比如按粒度，有表锁、行锁、gap锁；按锁的模式，有共享锁、排他锁、意向锁等</li><li>MySQL加锁问题与隔离级别有关，如果隔离级别是Read Commited，则不需要gap锁，因为RC允许幻读。</li><li>具体到各种锁<ol><li><code>全局锁</code>：对整个DB加锁，一些不支持事务的引擎，可以在备份前，锁住DB</li><li><code>MDL</code>，元数据锁：MDL分读/写，不需显式调用。MDL也是在语句执行时隐式加，在事务提交后释放。比如在对表做CURD时，加MDL读锁；对表做DDL时，加MDL写锁。</li><li><code>表锁</code>，读/写，共享/排他，S/X</li><li><code>行锁</code>，读/写，共享/排他，S/X</li><li><code>意向锁</code>，意向锁也是表级别，但是意向锁之间互不排斥，包括IX（意向写）与IX也不互斥。意向锁的目的是提高在加表锁时的判断效率。如果事务要给表中某一行加X锁，首先要对表加IX锁；如果要给某一行加S锁，就先对表加IS锁。这也是“意向”一词的含义。<br>如果一个事务要对表加X锁，就可以根据表有没有被其他事务加IS/IX锁，就可得知，有没有其他事务在读写该表。</li><li><code>间隙锁</code>，解决幻读问题</li><li><code>AI锁</code>，表级别，针对自增ID生成器，如果事务rollback，自增ID一列会不连续</li></ol></li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li><p>double write 机制   </p><p> InnoDB的page size一般是16KB，其数据校验也是针对这16KB来计算的，将数据写入到磁盘是以page为单位进行操作的。操作系统写文件是以4KB作为单位的，磁盘IO是以512字节为单位的，那么每写一个InnoDB的page到磁盘上，操作系统需要写4个块。而计算机硬件和操作系统，在极端情况下（比如断电）往往并不能保证这一操作的原子性，16K的数据，写入4K时，发生了系统断电或系统崩溃，只有一部分写是成功的，这种情况下就是partial page write（部分页写入）问题。这时page数据出现不一样的情形，从而形成一个”断裂”的page，使数据产生混乱。这个时候InnoDB对这种块错误是无 能为力的.   </p><p> 有人会认为系统恢复后，MySQL可以根据redo log进行恢复，而MySQL在恢复的过程中是检查page的checksum，checksum就是pgae的最后事务号，发生partial page write问题时，page已经损坏，找不到该page中的事务号，就无法恢复。   </p><p> 为了解决该问题，写数据page时，写两遍到磁盘，第一遍是写到double write buffer文件上, 第二遍是从double write buffer写到真正的数据文件中。如果宕机重启，发现page损坏，可以从double write buffer中恢复。   </p><p> 因为redo log的写入单位就是512字节，也就是磁盘IO的最小单位，因此可以保证原子性，不会导致数据损坏。</p></li></ol>]]></content>
    
    <summary type="html">
    
      总结一些mysql的知识点，包括范式、索引、事务、锁等等。
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>对CAP的正确理解</title>
    <link href="http://yoursite.com/2020/05/14/CAP/"/>
    <id>http://yoursite.com/2020/05/14/CAP/</id>
    <published>2020-05-14T03:06:27.000Z</published>
    <updated>2020-05-14T03:06:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ol><li>C，一致性，多副本一致性，事务一致性等</li><li>A，可用性</li><li>P，分区容忍性</li></ol><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>最大的误解：<strong>CAP可以三选二</strong><br>实际上P是必然存在的，只能在C和A（一致性和可用性）之间权衡。实际中大多是AP或CP系统，很少有CA的系统。</li><li>AP系统，追求可用性，放弃一致性。比如MySQL主从等。</li><li>CP系统，追求强一致性，牺牲一定的可用性。raft、zab协议。而此时的一致性，也只是对客户端看来是一致的，对内部看，是最终一致，因为同步数据总需要时间。</li><li>对于CA系统，因为要实现A（高可用），就必然有冗余，有冗余就必然存在P。比如MySQL，内部事务实现强一致性C，但是没有A，单机也不存在P。</li><li>只要引入冗余，实现的高可用（A），就一定存在P。如果还想兼顾一致性（C），那么一定不是真的A。<strong>因此实际系统中，总是在CA之间做权衡。放弃某一方，就变成了AP或CP。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CAP&quot;&gt;&lt;a href=&quot;#CAP&quot; class=&quot;headerlink&quot; title=&quot;CAP&quot;&gt;&lt;/a&gt;CAP&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;C，一致性，多副本一致性，事务一致性等&lt;/li&gt;
&lt;li&gt;A，可用性&lt;/li&gt;
&lt;li&gt;P，分区容忍性&lt;/li&gt;
&lt;/o
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Map并发安全实现原理</title>
    <link href="http://yoursite.com/2020/05/14/map%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/14/map%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-14T03:03:32.000Z</published>
    <updated>2020-05-14T03:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-Concurrent-hashmap"><a href="#Java-Concurrent-hashmap" class="headerlink" title="Java Concurrent hashmap"></a>Java Concurrent hashmap</h3><ol><li>多个segment，支持最大segment数量的并发访问<blockquote><p>ps: 如果hash桶的list过长，可以使用红黑树代替list</p></blockquote></li></ol><h3 id="golang-sync-Map"><a href="#golang-sync-Map" class="headerlink" title="golang sync.Map"></a>golang sync.Map</h3><ol><li>read-only, dirty 两个字段将读写分离</li><li>read-only不需加锁，读或写dirty都需要加锁</li><li>misses字段，统计read-only穿透次数，超过一定次数将dirty同步到read-only上</li><li>删除时，通过给read-only添加标记，延迟删除</li><li>读的时候，先查询read，不存在时查询dirty；写入时则只写入dirty</li><li>写入过程，每次写入时，先copy 未删除的read-only到dirty中，然后将k-v存入dirty。<blockquote><p>read-only可以当做dirty的缓存。dirty里的数据，总比read-only的多。</p></blockquote></li><li><strong>适用于读多写少的场景。写入较多时，性能无法保证。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java-Concurrent-hashmap&quot;&gt;&lt;a href=&quot;#Java-Concurrent-hashmap&quot; class=&quot;headerlink&quot; title=&quot;Java Concurrent hashmap&quot;&gt;&lt;/a&gt;Java Concurrent h
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>各种树结构</title>
    <link href="http://yoursite.com/2020/05/13/%E5%90%84%E7%A7%8D%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/05/13/%E5%90%84%E7%A7%8D%E6%A0%91%E7%BB%93%E6%9E%84/</id>
    <published>2020-05-13T02:21:07.000Z</published>
    <updated>2020-05-13T02:21:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="B树-vs-B-树-vs-B-树"><a href="#B树-vs-B-树-vs-B-树" class="headerlink" title="B树 vs B+树 vs B*树"></a>B树 vs B+树 vs B*树</h3><ol><li><p>B树，B是指发明人的名字</p><ul><li>平衡多路搜索树</li><li>保持键值有序，以顺序遍历</li><li>使用不完全填充的节点块，来加速插入和删除</li><li>节点块至少半满，提升空间利用率</li></ul></li><li><p>B+树 VS B树</p><ul><li>非叶子节点，只保存索引：从而可以减少索引树的大小，内存里可以保存更多的索引。由于每次都需要走到叶子节点，查询时间也更稳定。</li><li>叶子节点之间，增加链指针，方便遍历</li></ul></li><li><p>B*树<br>在B+树的基础上</p><ul><li>非根和非叶子节点，增加指向兄弟的指针</li><li>插入时，如果节点已满，会检查兄弟节点是否满，未满，则向兄弟节点转移数据；已满，则从当前节点和兄弟节点，各拿出1/3数据，创建一个新节点。<br>从而节点空间利用率更高，节点分裂的情况也减少。</li></ul></li></ol><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ol><li>也是一种BST(二叉搜索树)，但是不要求完全平衡</li><li>牺牲部分平衡性，达到较快的插入和删除性能</li><li>使用场景：linux CFS调度，nginx timer等</li><li>vs B树: B树作为多路搜索，能够在树深较小的情况下，支持更多的数据节点。对于磁盘类操作，可以避免大量的随机IO（一个磁盘page，可以读取到更多的索引，类似MySQL），从而优化读写性能。而红黑树一般整棵树都在内存里，不涉及到磁盘操作，支持的数据量较小，但是由于各种操作优于BST，因此常用于涉及到排序、搜索的场景。比如CFS，为了保证公平调度，每次选取当前执行总时间最小的线程执行。</li></ol><h3 id="LSM，Log-Structured-Merged-Tree"><a href="#LSM，Log-Structured-Merged-Tree" class="headerlink" title="LSM，Log-Structured Merged Tree"></a>LSM，Log-Structured Merged Tree</h3><ol><li>核心思想：<strong>放弃部分读性能，提高写性能。</strong>适用于kv存储</li><li>应用：rocksDB，levelDB，hbase<ul><li>rocksDB：c++编写的kv存储引擎</li><li>levelDB：kv存储引擎</li><li>hbase: 分布式存储，列数据库，应对大量数据（亿级以上）</li></ul></li><li>内存中的memtable，磁盘上的sstable。读取的时候，需要遍历sstable，这里的 优化是，使用是bloom filter，确定一个Key是否在sstable里。</li><li>一般LSM-Trees会配合内存排序，内存里将写数据缓冲（通常是一个(Red-Black Tree)红黑树结构）。等积累得足够多之后，使用归并排序将数据合并，写入磁盘。由于。</li><li>参考资料<ul><li><a href="http://blog.fatedier.com/2016/06/15/learn-lsm-tree/" target="_blank" rel="noopener">http://blog.fatedier.com/2016/06/15/learn-lsm-tree/</a></li></ul></li></ol><h3 id="lsm-vs-b-树"><a href="#lsm-vs-b-树" class="headerlink" title="lsm vs b+树"></a>lsm vs b+树</h3><ol><li><p>查询过程<br>为了快速查询，一个办法是建立hash索引，但是hash索引占用空间太大，而且不支持区间查询。另一个办法是，事先对数据进行排序，B+树，把排序的操作放在了写入的时候，读的时候便轻松一些。   </p></li><li><p>写过程<br> 但是B树面对高并发写的时候，压力很大。B树把所有的压力都放到了写操作的时候，从根节点索引到数据存储的位置，可能需要多次读文件；真正插入的时候，又可能会引起page的分裂，多次写文件。   </p><p> LSM在写的时候，直接写入内存，然后利用红黑树保持内存中的数据有序，由后台线程定期或被触发，去merge和持久化到磁盘。也会使用WAL方式记录log，避免数据丢失。  </p><p> 当写比读多时，LSM树相比于B树有更好的性能。因为随着insert操作，为了维护B树结构，节点分裂。读磁盘的随机读写概率会变大，性能会逐渐减弱。LSM把多次IO，批量变成一次IO，复用了磁盘寻道时间，极大提升效率。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;B树-vs-B-树-vs-B-树&quot;&gt;&lt;a href=&quot;#B树-vs-B-树-vs-B-树&quot; class=&quot;headerlink&quot; title=&quot;B树 vs B+树 vs B*树&quot;&gt;&lt;/a&gt;B树 vs B+树 vs B*树&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;B树，B是
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://yoursite.com/2020/05/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2020/05/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2020-05-12T13:35:11.000Z</published>
    <updated>2020-05-12T13:35:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><ol><li>set key val nx ex</li></ol><ul><li>优点：实现简单，性能好</li><li>缺点：超时时间不好控制，极端情况，会出现超时后，多个节点获取到同一把锁的情况。</li></ul><ol start="2"><li>问题<ol><li>主从，redis主从采用异步复制，那么如果主机宕机，切换到从，会导致部分锁数据丢失。此时，多个client会拿到同一把锁。</li><li>如果锁没有设置超时，若client挂掉，则锁永远不会释放</li><li>如果锁设置了超时，若client阻塞或业务执行超时，也会导致多个client拿到同一把锁。</li></ol></li></ol><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><ol><li>使用临时顺序节点，如果自己是子节点的第一个，则表示加锁成功。否则，watch上一个，如果上一个释放，表示轮到自己了。</li></ol><ul><li>优点：一般情况，不存在client宕机/超时问题，zk感知到client宕机，会自动删除对应的临时顺序节点，相当于自动释放锁，或者取消自己的排队。</li><li>缺点：实现复杂，吞吐量不高</li></ul><ol start="2"><li>问题<ol><li>因为zk使用心跳判断client是否在线，如果网络超时或者full GC等等，导致zk认为client宕机，则会释放锁。导致其他client同时获得该锁。<strong>但是这种情况很少见，相比之下，client处理超时这种更常见，这也是zk比redis方案好的原因。</strong></li></ol></li></ol><h3 id="mysql行锁"><a href="#mysql行锁" class="headerlink" title="mysql行锁"></a>mysql行锁</h3><ul><li>优点：不需引入额外中间件</li><li>缺点：吞吐量不高；也存在client宕机超时问题</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>探测client是否宕机很难，如果因为超时，那就不应该释放锁。如果是因为宕机，那就应该释放锁。</li><li><code>没有完美的方案，实际场景中，分布式锁只应作为辅助手段，比如为了减少DB的压力等，不应仅靠它控制业务并发逻辑。</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis&quot;&gt;&lt;a href=&quot;#redis&quot; class=&quot;headerlink&quot; title=&quot;redis&quot;&gt;&lt;/a&gt;redis&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;set key val nx ex&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;优点：实现简单，性能好&lt;/l
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="方案总结" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>高并发常见方案</title>
    <link href="http://yoursite.com/2020/05/12/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2020/05/12/%E9%AB%98%E5%B9%B6%E5%8F%91/</id>
    <published>2020-05-12T13:29:38.000Z</published>
    <updated>2020-05-12T13:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高并发写"><a href="#高并发写" class="headerlink" title="高并发写"></a>高并发写</h3><ol><li>数据分片<ul><li>数据库分库分表</li><li>JDK concurrentHashMap实现</li><li>kafka的partition</li><li>ES的分布式索引</li></ul></li><li>任务分片<ul><li>CPU的指令流水线</li><li>Map/Reduce</li><li>Tomcat 1+N+M 网络模型：1个监听线程，N个IO线程负责对socket进行读写，M个worker对请求做逻辑处理。</li></ul></li><li>异步化：异步接口、异步IO<ul><li>短信验证码注册/登录</li><li>订单系统</li><li>广告计费系统，异步，多消息合并扣费</li><li>Kafka的Pipeline</li></ul></li><li>WAL技术<ul><li>数据库redo log</li><li>LSM树 </li></ul></li><li>批量<ul><li>kafka的百万qps写入:partition分片，磁盘顺序写入，批量（leader/follower之间的批量，本地client之间的批量）</li><li>mysql的group commit机制，对多事务的redo log批量flush</li></ul></li></ol><h3 id="高并发读"><a href="#高并发读" class="headerlink" title="高并发读"></a>高并发读</h3><ol><li>加缓存<ul><li>本地缓存/redis/memcached</li></ul></li><li>增加副本冗余<ul><li>MySQL master/slave</li><li>CDN 静态文件加速</li></ul></li><li>并发读<ul><li>异步RPC</li><li>冗余请求，降低失败率</li></ul></li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;高并发写&quot;&gt;&lt;a href=&quot;#高并发写&quot; class=&quot;headerlink&quot; title=&quot;高并发写&quot;&gt;&lt;/a&gt;高并发写&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数据分片&lt;ul&gt;
&lt;li&gt;数据库分库分表&lt;/li&gt;
&lt;li&gt;JDK concurrentHashMap实现&lt;/l
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="方案总结" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>多副本一致性</title>
    <link href="http://yoursite.com/2020/05/12/%E5%A4%9A%E5%89%AF%E6%9C%AC%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://yoursite.com/2020/05/12/%E5%A4%9A%E5%89%AF%E6%9C%AC%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2020-05-12T03:23:33.000Z</published>
    <updated>2020-06-04T02:33:02.654Z</updated>
    
    <content type="html"><![CDATA[<h3 id="同步本质"><a href="#同步本质" class="headerlink" title="同步本质"></a>同步本质</h3><p>每台机器都把收到的请求按日志存下来，各机器的日志文件保持一致。选择存储“事件流”，而非最终状态，原因是：</p><ol><li>日志只有一种操作，append，相对简单</li></ol><h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h3><h4 id="1-Basic-Paxos"><a href="#1-Basic-Paxos" class="headerlink" title="1. Basic Paxos"></a>1. Basic Paxos</h4><ol><li>两个角色，Proposer 和 Acceptor，以及一个自增ID（n）</li><li>两个阶段，Propose阶段 和 Accept 阶段</li><li>Propose阶段<ol><li>proposer广播消息，id为n，prepare(n)</li><li>acceptor接收消息，如果n &gt; local N，则回复yes</li><li>proposer收到半数以上的yes，开始广播，否则id自增，重新广播</li></ol></li><li>Acctpt阶段<ol><li>proposer广播消息, accept(n, value)</li><li>acceptor接收消息，如果n &gt; loacal N，则持久化，返回yes</li><li>proposer收到半数以上的yes，则结束。否则id自增，从proposer阶段重新开始。</li></ol></li><li>两个问题<ol><li>Paxos是个不断循环的2PC，有可能陷入死循环，所谓“活锁”。比如3个node同时propose，都收到no，又同时n++，继续propose，继续no</li><li>性能：每次写入，需要两次RTT + 两次写盘。两次RTT分别是Propose/Accept阶段。这两个阶段都会持久化一些变量，需要磁盘IO。</li></ol></li><li>活锁问题<ol><li>多点写入，变为单点写入。选出一个leader，只让leader当proposer。从而减少冲突。leader选取办法，比如每个节点增加编号，使用心跳，选取编号最大的节点为leader。即使出现同一时间，多个leader，也不影响paxos的正确性，只会增大并发写冲突的概率。</li></ol></li></ol><h3 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h3><ol><li>单点写入：任一时刻，只允许一个有效的leader存在，所有的写请求，都传到leader上，然后由leader同步给超过半数的follower。</li><li>单条日志结构：term + index + content。term是leader的任期，只会单调递增；index是日志顺序编号，也是递增；</li><li>分为三个阶段，选举阶段，正常阶段，恢复阶段</li><li>选举阶段<ol><li>节点有三个状态：leader、follower、candidate。candidate是个中间状态。</li><li>当follower在一定时间收不到leader心跳时，就会随机sleep一个时间，然后变为candidate，发起选举。选举结束后，变为leader或follower。</li><li>选举算法，保证同一时间只有一个leader。<ol><li>如果选举请求里，日志的term和index比自己本地的新，则返回true，否则返回false。</li><li>candidate收到多数派返回true，则成为leader</li><li>每个节点只能投一次true，防止多个leader。因此选取出的leader不一定是最新的，但一定比大多数节点新。</li></ol></li></ol></li><li>正常阶段，复制日志<ol><li>只要超过半数的follower复制成功，就返回给客户端日志写入成功。</li><li>关键的日志一致性保证：<blockquote><ol><li>如果两个节点的日志，index和term相同，则内容一定相同。</li><li>如果index=M处的日志相同，则在M之前的日志，也一定相同。</li></ol></blockquote></li></ol></li><li>恢复阶段<ol><li>leader同步term给follower</li><li>以leader本地的日志为基准，复制给follower</li></ol></li><li>安全性保证<ol><li>leader数据是基准，leader不会从别的节点同步数据，只会是别的节点根据leader数据删除或追加自己的数据。</li><li>对于已经commit的日志，一定是commit的。对于新任leader上，前任leader未commit的日志，稍后会变为commit状态。不在新任leader上的未commit数据，会被覆盖。</li></ol></li></ol><h3 id="Zab"><a href="#Zab" class="headerlink" title="Zab"></a>Zab</h3><p>zookeeper使用的强一致性算法，同时也是单点写入，写请求都转发给leader。</p><ol><li>模型对比，复制状态机(replicated state machine, paxos/raft) vs 主备系统（primay-backup system，zab）,前者持久化的是客户端的请求序列（日志序列），另外一个持久化的是数据的状态变化。<ol><li>数据同步次数不一样，如果client执行三次x=1，后两次在主备系统里，不用触发同步。</li><li>存储状态变化，具有幂等性，而复制状态机不具备。</li></ol></li><li>zxid<ol><li>高32位，leader任期，类似raft的term</li><li>低32位，日志序列，类似raft的日志index</li></ol></li><li>三个阶段：Leader选举，BroadCast,恢复阶段</li><li>Leader选举：FLE算法<ol><li>Leader和Follower之间是双向心跳；raft里是单向</li><li>选取zxid最大的节点作为leader；和raft选取term+index最新的节点作为leader一个意思。</li></ol></li><li>broadcast阶段</li></ol><h3 id="raft-vs-zab"><a href="#raft-vs-zab" class="headerlink" title="raft vs zab"></a>raft vs zab</h3><p>参考：<a href="https://my.oschina.net/pingpangkuangmo/blog/782702" target="_blank" rel="noopener">https://my.oschina.net/pingpangkuangmo/blog/782702</a></p><ol><li>上一轮残留的数据怎么处理？</li></ol><p>首先看下上一轮次的leader在挂或者失去leader位置之前，会有哪些数据？</p><ul><li>已过半复制的日志</li><li>未过半复制的日志<br>一个日志是否被过半复制，是否被提交，这些信息是由leader才能知晓的，</li></ul><p>那么下一个leader该如何来判定这些日志呢？</p><p>下面分别来看看Raft和ZooKeeper的处理策略：</p><p>Raft：对于之前term的过半或未过半复制的日志采取的是保守的策略，全部判定为未提交，只有当当前term的日志过半了，才会顺便将之前term的日志进行提交</p><p>ZooKeeper：采取激进的策略，对于所有过半还是未过半的日志都判定为提交，都将其应用到状态机中</p><p>Raft的保守策略更多是因为Raft在leader选举完成之后，没有同步更新过程来保持和leader一致（在可以对外服务之前的这一同步过程）。而ZooKeeper是有该过程的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;同步本质&quot;&gt;&lt;a href=&quot;#同步本质&quot; class=&quot;headerlink&quot; title=&quot;同步本质&quot;&gt;&lt;/a&gt;同步本质&lt;/h3&gt;&lt;p&gt;每台机器都把收到的请求按日志存下来，各机器的日志文件保持一致。选择存储“事件流”，而非最终状态，原因是：&lt;/p&gt;
&lt;ol&gt;

      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="系统原理" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>开天辟地</title>
    <link href="http://yoursite.com/2020/05/11/%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0/"/>
    <id>http://yoursite.com/2020/05/11/%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0/</id>
    <published>2020-05-11T09:05:19.000Z</published>
    <updated>2020-05-14T03:04:18.669Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
