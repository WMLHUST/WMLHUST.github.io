---
title: 常见web安全总结
tags: [web安全]
categories: [后端,安全]
comments: true
date: 2020-05-25 16:20:55
updated: 2020-05-25 16:20:55
description: "总结常见的几种Web安全问题，包括XSS、CSRF、SQL注入。"
---
### XSS，跨站脚本攻击
XSS的根本原因是，前端页面被嵌入一些恶意代码，这些恶意代码可能通过不同途径，注入进来。根据不同注入途径（或着说方式），可以分为反射型、持久型。
1. 反射型XSS   
- 恶意伪造url -> 骗取用户点击 -> 页面从url取参数进行渲染。从而参数里的恶意代码被执行。
- 案例：微博hellosamy事件

2. 持久性XSS   
- 在留言板、评论等场景提交恶意代码 -> 后台未经处理，直接保存了前端提交的数据，-> 再次访问或其他人访问时，前端展示相关内容，又把这些数据取出来进行渲染，从而恶意代码被执行。  
- 案例：微信公众号XSS事件

3. 应对：
    1. 用户提交的数据，入库前预处理，很多xssfilter
    2. 前端拼接Html时，也要做充分转义
    3. 为了防止cookie盗用，重要cookie设置http-only为true

2. 参考   
    > `https://tech.meituan.com/2018/09/27/fe-security.html`

### CSRF，跨站请求伪造（英語：Cross-site request forgery）
本质是浏览器在发起请求时，会自动带上对应域名下的cookie。该特性可能导致，用户在访问恶意网站时，在用户不知不觉的情况下，触发一些携带了用户身份信息（cookie）的请求。如下图所示：
![CSRF示意图](/images/csrf.jpg)
> 1. 银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&money=1000
> 2. 危险网站B，它里面有一段HTML的代码如下：
>   ```html
>　　<img src=http://www.mybank.com/Transfer.php?toBankId=11&money=1000>
>   ```   
> 3. 首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块......

在访问危险网站B的之前，你已经登录了银行网站A，而B中的img以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取src指向的资源，结果银行网站服务器收到请求后，判断身份通过，所以就立刻进行转账操作......

该例子里，一方面是由于用户上了小网站，另一方面，不应该用GET请求去更新资源（更改账户）。因为像src/script等标签都是默认用GET获取资源，如果再对前端熟悉一些的，可能会想到jsonp，就是利用script标签实现的。   
很多邮箱图片默认不展示，CSRF也是原因之一。当然还有很多其他的风险，这个可以单开一篇，开开脑洞。

1. vs 跨域？   
很多人会有疑问，浏览器不是有跨域限制吗，为什么还会出现在A页面，访问B服务器的情况。对于跨域请求，**浏览器还是会正常发出**，收到response后，会判断源和当前页面的源是否是属于同源，如果不属于，则需要根据`access-control-allow-origin`等header，判断server端是否允许跨域。   

2. 应对   
主要通过两个关键点：   
    1. 虽然A网站可以向B服务器发请求，但是由于跨域限制，没法处理对应的response。因此一些更新资源的操作，最好用POST，更好的是使用restful风格。另一方面，也可以增加二次确认，比如引入验证码，实际上相当于一个动态的token。
    2. 由于正规的浏览器，对cookie访问，也要求同源。因此可以再query里增加一些cookie里才有的信息，在服务端校验query和cookie里对应的参数，如果不一致则为恶意。   

其他的方法，还有增加referer，但是有的时候请求不带referer，比如非http协议页面发出的请求（ftp之类的）、https页面发出的http请求等，因此该方法有一定的漏洞。

### SQL注入
关键点：
    1. 不要相信请求携带的参数，不要直接拿过来拼接SQL语句。   
SQL注入的防范很成熟，使用prepare statement即可，常用的client lib里都会实现。但是表名不支持参数化，因此表名还是得使用代码拼接的方式。这就要求表名不能是前端输入的，或者增加表名白名单校验。   
> 从一条sql执行过程来说，编译 -> 执行。一般情况是连带参数，一起编译，就会出现注入情况。   
  使用参数化查询的形式，会提前对模板进行预编译，而每个?占位的参数，只会被数据库当做一个完整的参数处理。
