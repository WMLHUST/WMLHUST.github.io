<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小本本</title>
  
  <subtitle>学而时习之，不亦说乎</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-25T03:37:42.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WordGe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gotrace工具使用整理</title>
    <link href="http://yoursite.com/2020/08/25/Gotrace%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/08/25/Gotrace%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/</id>
    <published>2020-08-25T03:37:42.000Z</published>
    <updated>2020-08-25T03:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>gotrace是观察goroutine调度和gc行为非常非常好的一个工具，但是无论官方，还是网上，都没有非常好的文档，特此记录、整理。读者最好有对golang的调度和GC过程有一定了解，可以参考：<a href="https://acac.fun/2020/08/18/Golang%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E6%A6%82%E8%A6%81/" target="_blank" rel="noopener">Golang部分原理概要</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://making.pusher.com/go-tool-trace/" target="_blank" rel="noopener">https://making.pusher.com/go-tool-trace/</a></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;gotrace是观察goroutine调度和gc行为非常非常好的一个工具，但是无论官方，还是网上，都没有非常好的文档，特此记录、整理。读者最好有对golang的调度和GC过程有一定了解，可以参考：&lt;a href=&quot;https://acac.fun/2020/08/18/Go
      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>GCtrace理解整理</title>
    <link href="http://yoursite.com/2020/08/25/GCtrace%E7%90%86%E8%A7%A3%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/08/25/GCtrace%E7%90%86%E8%A7%A3%E6%95%B4%E7%90%86/</id>
    <published>2020-08-25T03:37:28.000Z</published>
    <updated>2020-08-25T03:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前定位问题时，找了很多官方、网上的一些资料，现在整理出来：</p><p>export GODEBUG=gctrace=1，可以打开gc trace开关，具体信息会输出到stderr。<br>这是一个gc trace的一条具体信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5&#x2F;1.5&#x2F;0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 P</span><br></pre></td></tr></table></figure><p>可以分为几部分：</p><ol><li>整体指标  gc 1405 @6.068s 11%  </li></ol><ul><li>gc 1405，表示第1405次GC  </li><li>@6.068s, 表示程序启动至今，执行了6.068s  </li><li>11%，本次GC总共占用了11%的CPU  </li></ul><ol start="2"><li>墙上时间  0.058+1.2+0.083 ms clock  </li></ol><ul><li>0.058，Mark Prepare阶段的时间，STW状态  </li><li>1.2，Marking阶段的时间，就是并发mark阶段  </li><li>0.083，Mark Termination阶段耗时，STW状态<br>需要了解<a href="https://acac.fun/2020/08/18/Golang%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E6%A6%82%E8%A6%81/" target="_blank" rel="noopener">Golang GC的过程</a></li></ul><ol start="3"><li>CPU时间 0.70+2.5/1.5/0+0.99 ms cpu  </li></ol><ul><li>0.70，Mark Prepare阶段STW的CPU时间  </li><li>2.5，Marking阶段，mutator assist的CPU时间  </li><li>1.5，Marking阶段，background gc time，包括 delicated 和 fractional   </li><li>0，markding阶段，idle gc time  </li><li>0.99，Mark Termination阶段CPU时间  </li></ul><ol start="4"><li>内存  7-&gt;11-&gt;6 MB, 10 MB goal</li></ol><ul><li>7，mark之前的堆大小</li><li>11，mark之后的堆大小，意思是在marking过程中，又有4M的堆分配</li><li>6，mark结束后，被标记为存活的堆内存，意味着下次GC的目标是12Mb</li><li>10MB goal，下次堆内存达到10MB时，执行GC</li></ul><ol start="5"><li>12 P</li></ol><ul><li>P的数量，也就是GoMaxProcs大小</li></ul><ol start="6"><li>其他，GC forced</li></ol><ul><li>如果两分钟没有GC，就会强制执行一次GC，此时打印GC forced</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前定位问题时，找了很多官方、网上的一些资料，现在整理出来：&lt;/p&gt;
&lt;p&gt;export GODEBUG=gctrace=1，可以打开gc trace开关，具体信息会输出到stderr。&lt;br&gt;这是一个gc trace的一条具体信息。&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>常见缓存策略问题</title>
    <link href="http://yoursite.com/2020/08/20/%E5%B8%B8%E8%A7%81%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/08/20/%E5%B8%B8%E8%A7%81%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98/</id>
    <published>2020-08-20T08:19:28.000Z</published>
    <updated>2020-08-20T08:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、缓存穿透："><a href="#一、缓存穿透：" class="headerlink" title="一、缓存穿透："></a>一、缓存穿透：</h2><p>缓存穿透指，请求的key不在缓存中，因此会透过缓存，去请求DB或上游服务。具体可分三种情况：</p><ol><li><p>key有效，value不为空，然而未缓存<br>属于正常情况。</p></li><li><p>key有效，然而value为空，因此缓存未查到<br>为了避免重复访问，每次都穿透缓存，可以缓存一个约定好的无效值。读到该无效值即表示value为空，而无需访问DB。</p></li><li><p>key无效，缓存自然不存在<br>使用<code>布隆过滤器</code>或<code>位图</code>等，在处理请求前进行过滤，无效的key直接拒绝。当然需要预热，提前把有效的key放在<code>布隆过滤器</code>或<code>位图</code>里面。</p></li></ol><h2 id="二、缓存雪崩"><a href="#二、缓存雪崩" class="headerlink" title="二、缓存雪崩"></a>二、缓存雪崩</h2><p>缓存雪崩，是指大量的key-value同时失效，导致大量请求穿透去访问DB。为了避免这种情况：</p><ul><li>设置key过期时间时，增加随机范围；</li><li>缓存节点故障，也可能导致该问题。可以增加从节点，及时替换。缓存集群的多节点，可以使用一致性hash，将失效节点的访问分散到不同的节点上，避免引起连锁故障。</li></ul><h2 id="三、缓存热点"><a href="#三、缓存热点" class="headerlink" title="三、缓存热点"></a>三、缓存热点</h2><p>缓存热点，指有个别热点key访问特别大，比如明星、大V等，对热点key的访问可能会导致个别缓存节点压力巨大。<br>对于此类高并发读，可以设置多个副本，放置在不同的节点上，分摊压力。可以参考<a href="https://acac.fun/2020/05/12/%E9%AB%98%E5%B9%B6%E5%8F%91/" target="_blank" rel="noopener">高并发常见方案</a>。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>还有一种情况是，大量请求，访问同一个key，而这个key刚好失效，DB会收到大量读取同一行数据的请求。这就要求，同一节点，对于访问同一key的重复请求，只访问一次DB，简单地加一个互斥锁即可（和golang的sync.Once非常像），使用redis分布式锁也可以。</li><li><strong>缓存最重要的是，减少DB的压力。对于数据的安全、一致性还是需要关系型数据库实现。</strong></li><li>缓存本身也会面临各种各样的问题，包括性能、可用性等。读写性能可以参考<a href="https://acac.fun/2020/05/12/%E9%AB%98%E5%B9%B6%E5%8F%91/" target="_blank" rel="noopener">高并发常见方案</a>。可用性一般使用主从架构来实现，保证主机出问题，从机可以及时顶替上去。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、缓存穿透：&quot;&gt;&lt;a href=&quot;#一、缓存穿透：&quot; class=&quot;headerlink&quot; title=&quot;一、缓存穿透：&quot;&gt;&lt;/a&gt;一、缓存穿透：&lt;/h2&gt;&lt;p&gt;缓存穿透指，请求的key不在缓存中，因此会透过缓存，去请求DB或上游服务。具体可分三种情况：&lt;/p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Golang部分原理概要</title>
    <link href="http://yoursite.com/2020/08/18/Golang%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E6%A6%82%E8%A6%81/"/>
    <id>http://yoursite.com/2020/08/18/Golang%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E6%A6%82%E8%A6%81/</id>
    <published>2020-08-18T07:33:30.000Z</published>
    <updated>2020-08-18T07:33:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-协程实现与调度"><a href="#1-协程实现与调度" class="headerlink" title="1. 协程实现与调度"></a>1. 协程实现与调度</h3><p>协程，可以当做线程的一个个任务，不过线程会对协程进行调度，类似操作系统对线程做的调度。协程对比线程的优势在于：</p><ul><li>协程切换完全在用户空间进行，线程切换需要在内核空间完成</li><li>协程切换相比线程，需要切换的东西比较少，协程切换主要包括cpu寄存器；而线程出了cpu寄存器，还有线程私有的栈和寄存器等等。</li></ul><p>Golang里的GPM协程调度模型非常著名，简单地如下图所示：<br><img src="/images/golang_mpg.png" alt="GPM调度模型"><br>P充当了物理线程M和协程G之间的协调者，也可以说是对物理线程资源的一个封装，形成逻辑线程。<br>每个P关联一个等待被调度运行的G队列，P会依次执行。然而正常情况下，协程之间并不会出现抢占，而是依次排队执行。发生调度的时机如下所示：</p><ul><li>主动挂起</li><li>系统调用发生阻塞</li><li>协作式调度：在发生方法调用时，会检查标志</li><li>系统监控</li></ul><p>这里还有很多细节，比如如果某个P上面的G队列空了，然而其他P上的G都还是满的，这种时候怎么办？GoMaxProcs设置为CPU核数一定性能最好吗？  </p><h3 id="2-GC"><a href="#2-GC" class="headerlink" title="2. GC"></a>2. GC</h3><p>Golang的另一个优点在于，不用手动管理内存，比较像Java，Java运行时需要JVM，Golang不需要单独的VM，而是在编译时，内嵌一个小的Runtime，来处理GC、调度等事务。</p><p>整个GC大致分为4个阶段：  </p><blockquote><ol><li><p>Mark Prepare，<strong>需要STW</strong>，标记阶段准备工作，如标记根对象、开启写屏障和辅助GC等</p></li><li><p>Marking, 并发标记，<strong>不需STW</strong>，采用<strong>三色标记法</strong>，多个GC协程和多个用户协程可以并行运行。初始大概25%的P用于mark，逐个包括全局指针和G栈上的指针（扫描栈时，需要停止该G）。这部分工作叫gcBgMarkWorker。<br>如果保证marking过程中，其它G分配堆内存太快，导致mark跟不上allocate的速度，其它G还会被征用，配合做一部分mark的工作，称为mutator assists。<br>在marking期间，每次G分配内存，就会更新自己的gcAssistBytes，这个和G要帮忙mark的内存大小成正比。也就是mutator assist的工作量。</p></li><li><p>Mark Termination，标记结束，<strong>需要STW</strong>，关闭写屏障，重新扫描发生变化的对象，防止误回收。</p></li><li><p>Sweeping，并发清理，<strong>不需STW</strong>。清理回收的开销，被平摊到每次G的内存分配操作中，直到所有sweep任务完成。所以在go trace里看到sweep是和G并行运行的。另外go trace里的GC时间段，就不包括这部分时间。</p></li></ol></blockquote><p>随着Golang对GC的不断优化，当前的STW时间是非常短的，一般都在2ms以内。</p><p>非常推荐使用GoTrace观察一下实际运行中，Golang的协程调度表现，能够更好地理解调度与GC等过程。也可以打开gctrace开关，观察运行过程中的gc行为。</p><h3 id="3-defer原理"><a href="#3-defer原理" class="headerlink" title="3. defer原理"></a>3. defer原理</h3><p>每个goroutine会保存一个defer调用链，在方法执行结束时，取出链头，判断是否当前方法内设置的defer，是就执行，否则终止执行。</p><p>可以从编译期和运行期两个角度理解：  </p><ul><li>编译期：defer在会被转换为deferproc()方法，并在return前插入deferreturn()方法。</li><li>运行期：<br>deferproc()方法即会在goroutine的defer调用链头插入一个_defer结构体，代表当前被defer的方法。<br>deferreturn()会依次读取、执行goroutine的defer调用链。</li></ul><p><strong>注意Golang方法调用使用值传递，因而被defer方法的参数在defer()时已经确定。</strong></p><h3 id="4-panic与recover原理"><a href="#4-panic与recover原理" class="headerlink" title="4. panic与recover原理"></a>4. panic与recover原理</h3><p>同defer，每个goroutine维护一个自己的panic链表，发生panci后，会在panic链表插入一项。而recover则从panic链表依次读取处理。</p><p>同样可以从编译期和运行期理解panic和recover。</p><ul><li>编译期：panic()和recover()，会分别转换为gopanic()和gorecover()。  </li><li>运行期：<br>gopanic()，说明发生了panic，会插入panic到当前goroutine的panic链，然后循环执行defer链，此时即使非本方法的defer方法，也会被执行。如果执行完defer方法后，未recover，最终将终止整个进程。<br>gorecover()，一般recover都是放在defer里（放在defer外也不会生效，因为如果发生了panic，只有defer代码会被执行）。gorecover()从panic链获取待处理的panic，处理完后return会正常流程。</li></ul><p>因此，总结一下，panic如果不recover，会导致整个进程退出，而recover只能捕获自己goroutine的panic。所以，<strong>一个稳定的服务，要保证每个goroutine，都有defer recover()兜底。</strong> 当然，在recover中处理panic时，也要有响应的告警通知机制，以便开发及时发现处理。</p><h3 id="5-interface原理"><a href="#5-interface原理" class="headerlink" title="5. interface原理"></a>5. interface原理</h3><p>良好的interface设计，能够减少模块之间的耦合，隔离具体实现细节。<br>interface分为<code>iface</code>和<code>eface</code>，其中<code>eface</code>指不含method的interface。而face内部都有类似_type和_data两个指针，分别指向类型信息和具体对象信息。对于含有method的struct对象，_data里也记录了interface的方法列表。<br>方法之间传递时，struct与interface转换的合法性检测，发生在编译期。</p><p>golang内部，如果interface == nil，要求_type和_data同时为nil。</p><h3 id="6-channel原理"><a href="#6-channel原理" class="headerlink" title="6. channel原理"></a>6. channel原理</h3><p>golang的一个设计哲学是，不要通过共享内存来通信，而应该通过通信来共享数据。而goroutine之间就是使用channel进行高效的协程间通信。<br>由channel的FIFO特性，很容易想到队列，其实channel本身就是个队列。<br>channel内部实现的结构体如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/chan.go</span></span><br><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="keyword">uint</span>           <span class="comment">// 环形缓冲区中的元素个数</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span>           <span class="comment">// 环形缓冲区的容量</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 环形缓冲区的指针</span></span><br><span class="line">elemsize <span class="keyword">uint16</span>         <span class="comment">// 元素大小</span></span><br><span class="line">closed   <span class="keyword">uint32</span>         <span class="comment">// chan是否关闭</span></span><br><span class="line">elemtype *_type <span class="comment">// 元素类型</span></span><br><span class="line">sendx    <span class="keyword">uint</span>   <span class="comment">// 环形缓冲区的写入index</span></span><br><span class="line">recvx    <span class="keyword">uint</span>   <span class="comment">// 环形缓冲区的读取index</span></span><br><span class="line">recvq    waitq  <span class="comment">// 由于channel是空，读取阻塞的G队列</span></span><br><span class="line">sendq    waitq  <span class="comment">// 由于channel已满，写入阻塞的G队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">lock mutex  <span class="comment">// 互斥锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简洁明了，channel内部是使用一个环形缓冲区和一个互斥锁实现其队列机制，在此基础上做了一些优化，如：</p><ul><li>如果chan是空的，那么读取的G就会阻塞，那么下次写的G过来，可以不经过环形缓冲区，直接交给读取阻塞的G，从而提升效率</li><li>写chan阻塞同理  </li></ul><h3 id="7-定时器"><a href="#7-定时器" class="headerlink" title="7. 定时器"></a>7. 定时器</h3><p><strong>千万别以为定时器是精确触发的！！！</strong> 如果定期间隔 &lt;10ms，很多定时器的精确度都不够，包括golang的实现。<br>golang使用四叉堆来维护众多的timer。对定时器的检查有两个时机：</p><ul><li>G调度时</li><li>监控线程执行时  </li></ul><p>检查时，只需检查堆顶的timer（因为堆顶的timer是最先到期的），如果到触发时间，则起一个goroutine，执行对应回调函数。而goroutine的调度时间，也是不可控的，因此不能精确依赖定时器的触发时间。</p><p>还有一些其他的定时器实现方式，比如nginx使用红黑树、linux内核使用时间轮等。   </p><h3 id="8-内存分配"><a href="#8-内存分配" class="headerlink" title="8. 内存分配"></a>8. 内存分配</h3><p>内存分配<br>先说一下给对象 object 分配内存的主要流程：</p><ol><li>object size &gt; 32K，则使用 mheap 直接分配。</li><li>object size &gt; 16 byte &amp;&amp; size &lt;=32K byte 时，先使用 mcache 中对应的 size class 分配。</li><li>object size &lt; 16 byte，使用 mcache 的小对象分配器 tiny 直接分配。（其实 tiny 就是一个指针，暂且这么说吧。）</li><li>如果 mcache 对应的 size class 的 span 已经没有可用的块，则向 mcentral 请求。</li><li>如果 mcentral 也没有可用的块，则向 mheap 申请，并切分。</li><li>如果 mheap 也没有合适的 span，则想操作系统申请。</li></ol><h3 id="8-相关资料"><a href="#8-相关资料" class="headerlink" title="8. 相关资料"></a>8. 相关资料</h3><ul><li>也谈goroutine调度器：<a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="noopener">https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/</a></li><li>Go 语言设计与实现：<a href="https://draveness.me/golang/" target="_blank" rel="noopener">https://draveness.me/golang/</a> ，直接解读runtime源码</li><li>关于Golang GC的一些误解：<a href="https://zhuanlan.zhihu.com/p/77943973" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77943973</a></li><li>GC In Go: <a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html</a> ，系列的三篇文章都值得一读</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-协程实现与调度&quot;&gt;&lt;a href=&quot;#1-协程实现与调度&quot; class=&quot;headerlink&quot; title=&quot;1. 协程实现与调度&quot;&gt;&lt;/a&gt;1. 协程实现与调度&lt;/h3&gt;&lt;p&gt;协程，可以当做线程的一个个任务，不过线程会对协程进行调度，类似操作系统对线程做的
      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>redis关键原理-1</title>
    <link href="http://yoursite.com/2020/08/18/redis%E5%85%B3%E9%94%AE%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/08/18/redis%E5%85%B3%E9%94%AE%E5%8E%9F%E7%90%86/</id>
    <published>2020-08-18T07:32:44.000Z</published>
    <updated>2020-09-01T07:32:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>redis是单线程，使用epoll多路复用，来处理网络请求。特殊的时候会使用额外进程程，比如执行bgsave的时候，会fork一个子进程来创建RDB文件。</p><h2 id="不同类型数据的实现"><a href="#不同类型数据的实现" class="headerlink" title="不同类型数据的实现"></a>不同类型数据的实现</h2><h3 id="字符串（GET-SET…）"><a href="#字符串（GET-SET…）" class="headerlink" title="字符串（GET/SET…）"></a>字符串（GET/SET…）</h3><ol><li>存储结构：int/raw/embstr。  </li></ol><ul><li>raw：redis里重要的sds对象，相比C的原生string，有一些优化，如：空间预分配、惰性释放、防溢出等。  </li><li>embstr针对短字符串进行了优化，分配一块连续的空间；然而无法应对长度变化。</li></ul><h3 id="列表（LPUSH-RPUSH…）"><a href="#列表（LPUSH-RPUSH…）" class="headerlink" title="列表（LPUSH/RPUSH…）"></a>列表（LPUSH/RPUSH…）</h3><ol><li>存储结构：linkedlist / ziplist  </li></ol><ul><li>linkedlist: 双向链表</li><li>ziplist: 压缩列表，在元素较小(&lt;64字节)、较少(&lt;512个)时使用，可以节约内存，可以计算出最大使用32kb。使用一块连续的内存，类似数组的内存实现。</li></ul><h3 id="哈希（HSET-HGET…）"><a href="#哈希（HSET-HGET…）" class="headerlink" title="哈希（HSET/HGET…）"></a>哈希（HSET/HGET…）</h3><ol><li>存储结构：hashtable / ziplist</li></ol><ul><li><p>hashtable：</p><ul><li>使用单向链表解决冲突问题。</li><li>Hash算法使用 MurmurHash，计算速度快，冲突率低。</li><li>如果hashtable的负载因子过大或过小，会执行扩展或收缩，会有一个rehash动作。但是整个rehash动作不是一次性完成的，而是一个渐进的过程：<strong>将rehash分摊到每个添加、删除、查找和更新操作上，避免rehash巨大的工作量阻塞redis服务。</strong> 比如如果要查找，会同时在新旧hashtable里查找。</li></ul></li><li><p>ziplist：<br>使用压缩列表同样是为了节省内存，也同样是在元素较小(&lt;64byte)、较少(&lt;512)个时使用。此时hget的时间复杂度就不是O(1)了，而是O(N)，不过由于元素不多，查找耗时影响不明显。</p></li></ul><h3 id="集合-SADD-SREM…"><a href="#集合-SADD-SREM…" class="headerlink" title="集合 (SADD/SREM…)"></a>集合 (SADD/SREM…)</h3><ol><li>存储结构</li></ol><ul><li>hashtable：值为NULL</li><li>intset，整数集合：<br>类似<strong>有序的整数数组</strong>，也是为了节省内存，只有元素都是整数、数量较少(&lt;512个)时使用。</li></ul><h3 id="有序集合（ZADD-ZREM…）"><a href="#有序集合（ZADD-ZREM…）" class="headerlink" title="有序集合（ZADD/ZREM…）"></a>有序集合（ZADD/ZREM…）</h3><ol><li>存储结构</li></ol><ul><li><p>skiplist 和 hashtable</p><ul><li>skiplist，大名鼎鼎的跳跃表，优点是：实现较为简单，然而平均查找效率可以达到O(logN)级别。</li><li>对于跳跃表的结构、查找、插入过程可以参考网上的一些资料，或者查看<a href="https://github.com/redis/redis/blob/unstable/src/t_zset.c" target="_blank" rel="noopener">redis的源码</a>，非常简洁。</li><li>hashtable，主要是为了加快ZSCORE的速度，如果仅用skiplist，ZSCORE的时间复杂度是O(logN)，有了hashtable，复杂度可以降至O(1)。（空间、时间互换的思想到处都是啊，朴素的原理）</li></ul></li><li><p>ziplist，同样是为了降低内存占用，只有元素较小（&lt;64字节）、较少(&lt;128个)时使用</p></li></ul><h3 id="Expire的过期淘汰策略"><a href="#Expire的过期淘汰策略" class="headerlink" title="Expire的过期淘汰策略"></a>Expire的过期淘汰策略</h3><ol><li><p>定时删除：<br>在设置键过期时间的同时，创建定时器timer，到期后，立刻删除该键。<br>定时删除策略，对内存最友好，对CPU最不友好，处理大量的timer，也会占用很多CPU。</p></li><li><p>惰性删除：<br>redis在访问键的时候，检查过期时间。<br>对CPU最友好，但是对内存不友好。如果一个键过期后，不再访问到，将一直占用内存。</p></li><li><p>定期删除：<br>每隔一段时间，对redis进行一次检查，删除里面的过期键。  </p></li></ol><p><strong>需要合理设置触发频率和执行时长。</strong>  </p><p>redis同时使用惰性删除和定期删除两种策略。</p><h3 id="哨兵Sentinel"><a href="#哨兵Sentinel" class="headerlink" title="哨兵Sentinel"></a>哨兵Sentinel</h3><ol><li>哨兵是redis高可用的一个方案。可以用来监视redis主从集群的运行状况，及时替换故障节点。<br>sentinel也可以有多个，形成集群，共同监视redis集群。  </li><li>sentinel默认每10s使用info命令，探测一次主机的在线状态，也可以根据主机的回复，自动发现从机。</li><li>sentinel会订阅节点的<strong>sentinel</strong>:hello频道，也会通过给节点发送pub命令，往该频道发送消息。如此，多个sentinel便可互相探测到。  </li><li>多个sentinel时，会自动选举一个leader，选举算法是raft。发生故障时，以leader sentinel的决策为准。   </li><li>如果redis主机挂掉，sentinel选新的主机时，会根据优先级和复制偏移量确定选哪个从机。  </li></ol><h3 id="redis-cluster，分片集群"><a href="#redis-cluster，分片集群" class="headerlink" title="redis cluster，分片集群"></a>redis cluster，分片集群</h3><ol><li>节点信息（比如负责的slot区间）的传播使用gossip协议</li><li>集群分为16384个slot，集群中的每个节点可以处理0~16384个slot。只有每个slot都有节点在处理，集群才处于上线状态。每个节点都会记录，所有slot的指派节点。</li><li>节点收到命令时，会计算键属于哪个slot，如果slot不属于自己负责，则会向client返回一个MOVED IP:PORT错误，客户端再次向正确的节点发送请求。</li><li>重新分片，类似rehash的过程，不过这个是批量的，而非渐进式的。迁移过程中的查询过程与rehash过程类似。</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><p>共享对象：对于整数型的数据，redis可以在不同kv间共享，来减少内存使用。对字符串不共享，因为字符串的比较复杂度是O(N)，而数字是O(1)。</p></li><li><p>redis使用引用计数来回收内存，不用担心循环引用，因为引用关系简单</p></li><li><p>主从模式下，过期键的删除由主机控制，从机不会主动删除过期键，而会等待主机删除时发过来的DEL命令控制。造成的问题是，如果键过期，主机未删除，在从机还会正常读到。</p></li><li><p>主从同步过程：  </p><ul><li>master 执行bgsave 备份rdb镜像，并同时将后续修改操作记录到内存buffer</li><li>master备份完成后，先将rdb文件传输给slave</li><li>slave将rdb镜像加载到内存，之后重放master备份期间的修改即可</li></ul></li><li><p>如果一个主机有多个从机，那么当主机故障时，多个从机会选举出一个主机，选举算法同样基于raft。</p></li><li><p>redis有个周期函数，每100ms执行一次，来对正在运行的服务器进行维护。比如：执行定期删除策略、检查是否满足save条件等。</p></li><li><p>RDB文件是二进制格式，会对KV进行压缩，存储KV的时候，大致是Type-Key-Value的形式。</p></li><li><p>AOF包含的只有写命令。为了解决AOF文件体积膨胀的问题，可以执行AOF重写操作。在执行BGREWRITEAOF命令时，redis会维护一个AOF重写缓冲区，记录执行期间的所有写命令。子进程重写AOF完成后，再将缓冲区的内容，追加到新的AOF文件末尾，解决重写AOF期间的命令丢失问题。</p></li><li><p>redis的复制：关键点在于同步和命令传播。同步是在从机启动时，直接将主机的RDB文件拉过来；同步成功后，会进入命令传播阶段，主机会将每一个写命令同步给从机。2.8版本以前，即使命令在传播过程中丢失，主、从都不会注意到，也不会重传。2.8版本及以后，增加了offset的概念，来实现部分同步和命令重传。</p></li><li><p>当前的redis订阅&amp;消费模式，不会保存消息，如果publish时，subscriber不在线，将错过这条消息。更没有对消息持久化的操作。简单地理解，消息只会发送给当时在线的消费者。</p></li><li><p>multi vs pipeline：</p><ul><li>multi命令缓冲在server，pipeline缓冲在client</li><li>multi，每个命令client会发送一次，pipeline是一次发送积累的多个命令</li><li>multi/exec可以保证多个命令的执行在一个原子操作中，不被其他client的命令打断，pipeline不保证</li></ul></li><li><p>WATCH命令，在exec时，检查watched keys，如果value发生了变化，就拒绝执行</p></li><li><p>redis事务和传统RDBMS事务，最大的区别在于，redis不支持回滚，即使事务队列的某个命令执行期间出错，整个事务也会继续执行剩下的命令。因此可以说，不满足原子性的要求：要么全部成功，要么全部失败。对于C一致性、I隔离性、D持久性，redis是可以满足的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IO模型&quot;&gt;&lt;a href=&quot;#IO模型&quot; class=&quot;headerlink&quot; title=&quot;IO模型&quot;&gt;&lt;/a&gt;IO模型&lt;/h2&gt;&lt;p&gt;redis是单线程，使用epoll多路复用，来处理网络请求。特殊的时候会使用额外进程程，比如执行bgsave的时候，会for
      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="系统原理" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>谈一下接口安全</title>
    <link href="http://yoursite.com/2020/08/14/%E8%B0%88%E4%B8%80%E4%B8%8B%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2020/08/14/%E8%B0%88%E4%B8%80%E4%B8%8B%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8/</id>
    <published>2020-08-14T02:35:20.000Z</published>
    <updated>2020-08-14T02:35:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>此处安全非指SQL注入、XSS等web安全，而是指业务安全，比如权限、伪造参数等，包括但不限于http以及其他rpc协议的接口。<br>举个栗子，很多业务春节活动都会发红包，那么有一个独立的发红包服务，如何分配、控制接口的权限等安全？如何应对发放失败问题？这里提供几个思路，欢迎一起探讨，欢迎指出错误。</p><h2 id="1-https-client证书"><a href="#1-https-client证书" class="headerlink" title="1 https + client证书"></a>1 https + client证书</h2><p>日常我们使用https，都是client校验server证书；实际上，也可以给用户分配client证书，以验证客户端身份。</p><h3 id="1-1-优点"><a href="#1-1-优点" class="headerlink" title="1.1 优点"></a>1.1 优点</h3><p>可以有效保证server/client身份的真实性，只要client证书不泄露，就可保证client调用是正常的。</p><h3 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 缺点</h3><ol><li>不支持http，性能没有http好</li><li>若使用内网捕获的请求，直接重放，还是可以突破限制（很多时候是无意的，比如安全同事对接口的扫描；或测试环境的流量录制重放）</li></ol><h2 id="2-client-ip白名单"><a href="#2-client-ip白名单" class="headerlink" title="2 client ip白名单"></a>2 client ip白名单</h2><p>server只处理来自源ip在白名单内的请求。</p><h3 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h3><ol><li>一个大胆的想法，除非在client出口网关处，做tcp/ip包级别的解析伪造，其他情况可以保证安全。</li><li>改造简单，甚至无需改造</li></ol><h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><ol><li>未解决请求重放问题</li><li>不适用于client ip经常发生变化的场景，比如ADSL拨号、服务自动扩容等</li></ol><h2 id="3-token-加密"><a href="#3-token-加密" class="headerlink" title="3 token 加密"></a>3 token 加密</h2><p>该token仅保存在client和server本地，不应该在请求里携带原始token，避免泄露。常见的是，用做加密或签名算法的key，。一般情况，用签名算法，比如md5(params+key)。加密算法，加密后的数据会特别长，影响性能。</p><h3 id="3-1-优点"><a href="#3-1-优点" class="headerlink" title="3.1 优点"></a>3.1 优点</h3><p>实现简单、改造简单</p><h3 id="3-2-缺点"><a href="#3-2-缺点" class="headerlink" title="3.2 缺点"></a>3.2 缺点</h3><p>未解决请求重放问题，可以用以下两种思路优化一下。</p><h3 id="3-3-优化一：增加-随机数、时间戳-参数"><a href="#3-3-优化一：增加-随机数、时间戳-参数" class="headerlink" title="3.3 优化一：增加 随机数、时间戳 参数"></a>3.3 优化一：增加 随机数、时间戳 参数</h3><p>以md5(params+key)为例：  </p><ol><li>params增加<code>随机数</code>，使用redis检测是否重复。但不可能永久保存所有的随机数，随着累积，随机数冲突的概率会越来越大。因此需要给随机数增加时效性，比如半个小时过期。可解决半个小时内的重放问题。</li><li>params增加<code>时间戳</code>，接口增加逻辑，检测时间戳是否在前后十分钟。防止随机数过期后，使用之前的请求重放攻击。可解决在半个小时候的重放问题（因为请求带的时间戳不在有效期）。  </li></ol><p>不用担心<code>随机数</code>或<code>时间戳</code>被伪造，如果被伪造了，签名会通不过。</p><h4 id="3-3-1-优化一优点"><a href="#3-3-1-优化一优点" class="headerlink" title="3.3.1 优化一优点"></a>3.3.1 优化一优点</h4><ol><li>实现简单，改造方便</li></ol><h4 id="3-3-2-优化一缺点"><a href="#3-3-2-优化一缺点" class="headerlink" title="3.3.2 优化一缺点"></a>3.3.2 优化一缺点</h4><ol><li>要求client与server时区一致，并且时间偏差不大。</li><li>丢包/服务超时，可能会误使client认为请求失败，并重新请求。如果是充值、转账类接口，会导致server处理多次。此时需要幂等。</li></ol><h3 id="3-4-优化二：幂等"><a href="#3-4-优化二：幂等" class="headerlink" title="3.4 优化二：幂等"></a>3.4 优化二：幂等</h3><p>以md5(params+key)为例  </p><ol><li>增加<code>订单id</code>参数，server实现同一订单id处理的幂等性。client保证不同请求的<code>订单id</code>不重复，重试请求的<code>订单id</code>不变。</li><li>加密params也增加<code>订单id</code>，防止订单id伪造。</li></ol><h4 id="3-4-1-优化二优点"><a href="#3-4-1-优化二优点" class="headerlink" title="3.4.1 优化二优点"></a>3.4.1 优化二优点</h4><ol><li>可以从数据层面最大程度保证安全</li><li>配合appid + token，可以作为一个支付系统的基本安全机制</li></ol><h4 id="3-4-2-优化二缺点"><a href="#3-4-2-优化二缺点" class="headerlink" title="3.4.2 优化二缺点"></a>3.4.2 优化二缺点</h4><ol><li>实现、改造成本较高：要求client和server都支持订单id，<strong>client要保证生成的订单id不重复，并且重试时订单id不变。server要保证订单处理的幂等性。</strong> </li></ol><h2 id="4-微信支付，企业付款接口安全分析"><a href="#4-微信支付，企业付款接口安全分析" class="headerlink" title="4 微信支付，企业付款接口安全分析"></a>4 微信支付，企业付款接口安全分析</h2><p>该接口可以通过商户号，给微信用户转账。</p><h3 id="4-1-文档地址"><a href="#4-1-文档地址" class="headerlink" title="4.1 文档地址"></a>4.1 文档地址</h3><p><a href="https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2</a></p><h3 id="4-2-主要有以下安全措施"><a href="#4-2-主要有以下安全措施" class="headerlink" title="4.2 主要有以下安全措施"></a>4.2 主要有以下安全措施</h3><ol><li>限定https: 防范中间人</li><li>client证书：client身份校验</li><li>ip白名单: client鉴权</li><li>md5签名: 见上文，文档：<a href="https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=4_3" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=4_3</a></li><li>随机字符串: 增加签名校验逆向难度</li><li>订单id + server订单处理时的幂等性</li></ol><h3 id="4-3-分析"><a href="#4-3-分析" class="headerlink" title="4.3 分析"></a>4.3 分析</h3><p>感觉安全限制是非常严格了。。。。  </p><ol><li>不知server有未对随机数进行去重，但由于server订单处理的幂等性，基本可以应对重放攻击的问题。</li><li>若想破解，要同时解决：client证书、ip白名单、md5key三个问题。</li></ol><h2 id="5-QQ钱包，企业付款接口安全分析"><a href="#5-QQ钱包，企业付款接口安全分析" class="headerlink" title="5. QQ钱包，企业付款接口安全分析"></a>5. QQ钱包，企业付款接口安全分析</h2><p>该接口可以通过商户号，给QQ用户转账。</p><h3 id="5-1-文档地址"><a href="#5-1-文档地址" class="headerlink" title="5.1 文档地址"></a>5.1 文档地址</h3><p><a href="https://qpay.qq.com/buss/wiki/206/1215" target="_blank" rel="noopener">https://qpay.qq.com/buss/wiki/206/1215</a></p><h3 id="5-2-安全措施"><a href="#5-2-安全措施" class="headerlink" title="5.2 安全措施"></a>5.2 安全措施</h3><ol><li>限定https：防范中间人</li><li>client证书：client身份鉴权</li><li>md5签名，与微信支付类似</li><li>不超过32位的随机字符串：增加签名校验逆向难度</li><li>订单id + server订单处理时的幂等性</li><li>op_user_id和md5(passwd)：商户操作员账号和密码</li></ol><h3 id="5-3-分析"><a href="#5-3-分析" class="headerlink" title="5.3 分析"></a>5.3 分析</h3><ol><li>和微信接口的区别在于，微信支付接口多了ip白名单；QQ支付接口多了账号和密码</li><li>若想破解，要同时解决：client证书、md5key、op_user账号三个问题。</li></ol><h2 id="6-总结一下"><a href="#6-总结一下" class="headerlink" title="6. 总结一下"></a>6. 总结一下</h2><p>问题可以分为两类，应对非法请求的鉴权，和应对合理请求的重试。</p><h3 id="6-1-非法请求鉴权"><a href="#6-1-非法请求鉴权" class="headerlink" title="6.1 非法请求鉴权"></a>6.1 非法请求鉴权</h3><ol><li>https：防范中间人，防止数据被嗅探，以及确认server合法性</li><li>client证书：确认client身份</li><li>ip白名单</li><li>appid + token签名 + 随机字符串 + 时间戳：应对重放攻击和请求篡改</li></ol><h3 id="6-2-合法请求重试"><a href="#6-2-合法请求重试" class="headerlink" title="6.2 合法请求重试"></a>6.2 合法请求重试</h3><ol><li>引入订单id和幂等处理：client生成不重复的订单id，服务端处理时保证幂等操作。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此处安全非指SQL注入、XSS等web安全，而是指业务安全，比如权限、伪造参数等，包括但不限于http以及其他rpc协议的接口。&lt;br&gt;举个栗子，很多业务春节活动都会发红包，那么有一个独立的发红包服务，如何分配、控制接口的权限等安全？如何应对发放失败问题？这里提供几个思路，
      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="后台安全" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务常见方案</title>
    <link href="http://yoursite.com/2020/07/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/07/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-07-25T15:50:31.000Z</published>
    <updated>2020-07-25T15:50:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>分布式事务是个复杂繁琐的问题，如果能够通过调整业务或架构，避免分布式事务，尽量避免。</strong></p><p>下面总结、对比一下常见的分布式事务实现方案：</p><h3 id="1-2PC-XA"><a href="#1-2PC-XA" class="headerlink" title="1. 2PC / XA"></a>1. 2PC / XA</h3><p>XA规范的协议原理即为 2PC。关键点：</p><ol><li>需要一个事务协调器。</li><li>每个实例，分为两个阶段，第一阶段<code>prepare</code>，第二阶段，<code>commit/rollback</code>。   </li></ol><p>存在问题：</p><ol><li>事务协调器，单点故障。故障时，为了保证事务连续，只能等待该协调器重启恢复。</li><li>性能问题，阶段1，锁定资源后，必须要等所有节点返回，然后才能一同进入阶段2。</li><li>如果commit部分成功，将出现数据不一致。此时只能不断重试，直到成功。</li></ol><h3 id="2-3PC"><a href="#2-3PC" class="headerlink" title="2. 3PC"></a>2. 3PC</h3><p>3PC的三个阶段分别是<code>canCommit</code>、<code>preCommit</code>、<code>doCommit</code>。<br>相比两阶段提交：</p><ol><li>多了preCommit一步，实际是把2PC划分得更细。2PC在阶段1时，如果部分成功，则rollback。而在阶段2时，如果部分成功（实际上，每个实例应该保证，一旦收到commit，必定能成功。前提条件检查应放在阶段1做。），则只能不断重试。3PC拆分得更细后，根据不同阶段的超时，执行不同的动作，避免系统长时间阻塞。<br>当然，2PC中，实例也可以在阶段2，等待commit超时后rollback。不能是commit，因为可能阶段1不是全部成功，出于一致性考虑，只能rollback，然后调用方不断重试。<br>3PC分为两个阶段后，超时更好控制。在阶段2等待preCommit超时和2PC中等待commit超时一样，需要rollback，因为无法保证所有实例在阶段1的canCommit都OK。但是如果在阶段3等待doCommit超时，至少能确定canCommit都是成功的，因此可以执行commit。</li><li>相比2PC，增加超时功能，减少对事务协调器的依赖，避免持续阻塞：<ul><li>实例回复完canCommit，在收到preCommit之前超时后自动 rollback，此时无法保证canCommit都回复OK，因此得rollback</li><li>实例回复完preCommit，在第三阶段，停留超时后自动 commit，此时可以保证canCommit都回复OK，因此commit</li></ul></li></ol><p>然而，3PC也需要协调者，协调者也需要等待各个实例的回复，这些回复也可能超时，超时后也会重试。<strong>根源在于，通信信道没有保证，因此两个节点之间，如果超时，无法确定对方是宕机了，还是消息丢失了。所以，此时是成功了，还是失败了呢？</strong><br>以及3PC也可能出现不一致的情况，比如进入preCommit阶段，部分实例回复OK，进入doCommit阶段（超时会自动Commit），此时另一部分网络中断，preCommit阶段超时后rollback。就出现了多实例的不一致。真正分布式一致性还要靠paxos、raft之类的一致性协议。  </p><p>参考文章：</p><ul><li><a href="https://csruiliu.github.io/blog/20160530-intro-3pc/" target="_blank" rel="noopener">https://csruiliu.github.io/blog/20160530-intro-3pc/</a></li></ul><h3 id="3-TCC"><a href="#3-TCC" class="headerlink" title="3. TCC"></a>3. TCC</h3><p>TCC (<code>Try - Confirm - Cancel</code>)<br>相比TCC，更偏向应用层一点，比如服务间调用，各阶段之间会穿插一些业务逻辑等。2PC、3PC更像是协调两个数据库实例。比如：一个订单服务需要支付、库存、积分、物流多个服务的状态保持一致。一般使用一些TCC事务框架，框架需要保存事务日志之类的。   </p><ul><li>如果try失败，调用cancel</li><li>如果confirm失败，不停重试confirm</li><li>如果cancel失败，不停重试cancel   </li></ul><p>因此try/confirm/cancel接口需要幂等，因此需要一些事务ID之类的东西，TCC框架可以协助实现。</p><p>参考文章：</p><ul><li>介绍TCC流程，<a href="https://juejin.im/post/5bf201f7f265da610f63528a" target="_blank" rel="noopener">https://juejin.im/post/5bf201f7f265da610f63528a</a></li><li>介绍TCC细节，<a href="https://yemablog.com/posts/tcc-1" target="_blank" rel="noopener">https://yemablog.com/posts/tcc-1</a></li><li><a href="https://toutiao.io/posts/iwqysv/preview" target="_blank" rel="noopener">https://toutiao.io/posts/iwqysv/preview</a></li></ul><h3 id="4-消息中间件（实现的是最终一致）"><a href="#4-消息中间件（实现的是最终一致）" class="headerlink" title="4. 消息中间件（实现的是最终一致）"></a>4. 消息中间件（实现的是最终一致）</h3><p>这个没啥特别的，主要是利用消息队列解耦，从而A完成事务后可直接返回，B从MQ中取消息，发生错误则不断尝试。<br><img src="/images/tx-mq.jpg" alt=""></p><p>特别提一下rocketMQ事务消息的实现原理：<br>rocketMQ的消息发送，分为两个阶段：prepare和confirm。<br>当confirm后，broker才会将消息传递给消费方。<br>对于一直未confirm的消息，broker会定期扫描，询问发送方此消息，是发送还是取消。   </p><p>再特别提一下，两个服务之间，最终一致性的关键：<br>持久化中间件（MySQL，消息对列等），配合幂等重试。<br>比如转账，A服务扣了钱，记录进DB。异步调用B服务加钱接口，失败则重试，直到成功。（失败多次后，一般会人工介入）。如果有必要，成功后回调A服务，通知该订单已完成。   </p><p>然而基于消息队列的方案，只适合允许异步的场景。有的比如用户下单和扣库存，这种是多个操作共同决定了整个事务的成功与否，需要同步得到结果，就更适合使用TCC这种带补偿机制的方案，所谓补偿是指cancel操作会释放资源回池。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/" target="_blank" rel="noopener">https://xiaomi-info.github.io/2020/01/02/distributed-transaction/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;分布式事务是个复杂繁琐的问题，如果能够通过调整业务或架构，避免分布式事务，尽量避免。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面总结、对比一下常见的分布式事务实现方案：&lt;/p&gt;
&lt;h3 id=&quot;1-2PC-XA&quot;&gt;&lt;a href=&quot;#1-2PC-XA&quot; class
      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="系统原理" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>python多元赋值的一个顺序问题</title>
    <link href="http://yoursite.com/2020/07/12/python%E5%A4%9A%E5%85%83%E8%B5%8B%E5%80%BC%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/07/12/python%E5%A4%9A%E5%85%83%E8%B5%8B%E5%80%BC%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-12T10:50:22.000Z</published>
    <updated>2020-07-12T10:50:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>起因是试验一个python翻转链表的代码，python的变量交换非常方便，比如交换两个元素，可以直接<code>a, b = b, a</code>，因此翻转链表，可以这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(head: ListNode)</span> :</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        cur, pre, cur.next = cur.next, cur, pre</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><p>然而，这个代码是错误的。</p><p>经过单步debug，发现在第一次交换发生时，交换的结果就不对。<br>不用怀疑，如果是 <code>a, b, c = b, c, a</code>，那肯定是对的。所以问题出在哪里？不会是python的一个bug吧？<br>追根溯源，直接看下字节码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化链表</span></span><br><span class="line">n0 = ListNode(<span class="number">0</span>)</span><br><span class="line">n1 = ListNode(<span class="number">1</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">3</span>)</span><br><span class="line">n0.next = n1</span><br><span class="line">n1.next = n2</span><br><span class="line">n2.next = n3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看交换代码的字节码</span></span><br><span class="line">pre = <span class="literal">None</span></span><br><span class="line">cur = n0</span><br><span class="line">dis.dis(<span class="string">"cur, pre, cur.next = cur.next, cur, pre"</span>)</span><br></pre></td></tr></table></figure><p>输出是   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0-10步，先依次取右值 cur.next, cur, pre，然后倒序</span></span><br><span class="line"> <span class="number">0</span> LOAD_NAME     <span class="number">0</span> (cur)   <span class="comment"># 取cur值，push入栈</span></span><br><span class="line"> <span class="number">2</span> LOAD_ATTR     <span class="number">1</span> (next)  <span class="comment"># 取cur.next，替换栈顶</span></span><br><span class="line"> <span class="number">4</span> LOAD_NAME     <span class="number">0</span> (cur)   <span class="comment"># 取cur值，push入栈</span></span><br><span class="line"> <span class="number">6</span> LOAD_NAME     <span class="number">2</span> (pre)   <span class="comment"># 取pre值，push入栈</span></span><br><span class="line"> <span class="number">8</span> ROT_THREE</span><br><span class="line"><span class="number">10</span> ROT_TWO                 <span class="comment"># ROT_3和ROT_2两步的效果，就是对栈内的3个元素倒序</span></span><br><span class="line">                           <span class="comment"># 目前栈内从顶至底分别为[old_cur_next, old_cur, old_pre]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上步骤没有问题，提前准备好要赋值的数据。</span></span><br><span class="line"><span class="comment"># 接下来，依次赋值左边变量，cur, pre, cur.next</span></span><br><span class="line"><span class="number">12</span> STORE_NAME    <span class="number">0</span> (cur)   <span class="comment"># pop栈顶，赋值给 cur (new_cur = old_cur_next)</span></span><br><span class="line">                           <span class="comment"># 此时栈 [old_cur, old_pre]</span></span><br><span class="line"></span><br><span class="line"><span class="number">14</span> STORE_NAME    <span class="number">2</span> (pre)   <span class="comment"># pop栈顶，赋值给 pre (new_pre = old_cur)</span></span><br><span class="line">                           <span class="comment"># 此时栈 [old_pre]</span></span><br><span class="line"></span><br><span class="line"><span class="number">16</span> LOAD_NAME     <span class="number">0</span> (cur)   <span class="comment"># 取cur值，push入栈</span></span><br><span class="line">                           <span class="comment"># 此时栈 [new_cur, old_pre]</span></span><br><span class="line"></span><br><span class="line"><span class="number">18</span> STORE_ATTR    <span class="number">1</span> (next)  <span class="comment"># 将栈顶元素(也就是cur)的next属性，赋值为栈的第二个元素</span></span><br><span class="line">                           <span class="comment"># new_cur.next = old_pre</span></span><br></pre></td></tr></table></figure><p>关键在于第16步，重新load了一下cur，而此时cur已经在第12步，被赋值为old_cur_next。实际执行的是<code>new_cur.next = old_pre</code>，而我们的目标是<code>old_cur.next = old_pre</code>。因此出现了不一致。</p><p>关键在于 <strong>多元赋值中，左边被赋值的变量是有先后关系的。先改变了cur，那么再给cur.next赋值时，cur就已经是新的cur。因此如果同时需要改变cur、cur.next的值，应该优先赋值cur.next。</strong></p><p>修改后的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(head: ListNode)</span> :</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># cur, pre, cur.next = cur.next, cur, pre</span></span><br><span class="line">        cur.next, pre, cur  = pre, cur, cur.next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;起因是试验一个python翻转链表的代码，python的变量交换非常方便，比如交换两个元素，可以直接&lt;code&gt;a, b = b, a&lt;/code&gt;，因此翻转链表，可以这么写：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题目思路简结-3</title>
    <link href="http://yoursite.com/2020/06/25/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93-3/"/>
    <id>http://yoursite.com/2020/06/25/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93-3/</id>
    <published>2020-06-25T01:36:29.000Z</published>
    <updated>2020-06-25T01:36:29.000Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><pre><code>1. [剑指 Offer 50. 第一个只出现一次的字符](#剑指-offer-50-第一个只出现一次的字符)2. [剑指 Offer 51. 数组中的逆序对](#剑指-offer-51-数组中的逆序对)3. [剑指 Offer 52. 两个链表的第一个公共节点](#剑指-offer-52-两个链表的第一个公共节点)4. [剑指 Offer 53 - I. 在排序数组中查找数字 I](#剑指-offer-53---i-在排序数组中查找数字-i)5. [指 Offer 53 - II. 0～n-1中缺失的数字](#指-offer-53---ii-0n-1中缺失的数字)6. [剑指 Offer 54. 二叉搜索树的第k大节点](#剑指-offer-54-二叉搜索树的第k大节点)7. [剑指 Offer 55 - I. 二叉树的深度](#剑指-offer-55---i-二叉树的深度)8. [剑指 Offer 55 - II. 平衡二叉树](#剑指-offer-55---ii-平衡二叉树)9. [剑指 Offer 56 - I. 数组中数字出现的次数](#剑指-offer-56---i-数组中数字出现的次数)10. [剑指 Offer 56 - II. 数组中数字出现的次数 II](#剑指-offer-56---ii-数组中数字出现的次数-ii)11. [剑指 Offer 57 - II. 和为s的连续正数序列](#剑指-offer-57---ii-和为s的连续正数序列)12. [剑指 Offer 58 - I. 翻转单词顺序](#剑指-offer-58---i-翻转单词顺序)13. [剑指 Offer 58 - II. 左旋转字符串](#剑指-offer-58---ii-左旋转字符串)14. [剑指 Offer 59 - I. 滑动窗口的最大值](#剑指-offer-59---i-滑动窗口的最大值)15. [剑指 Offer 59 - II. 队列的最大值](#剑指-offer-59---ii-队列的最大值)16. [剑指 Offer 60. n个骰子的点数](#剑指-offer-60-n个骰子的点数)17. [剑指 Offer 61. 扑克牌中的顺子](#剑指-offer-61-扑克牌中的顺子)18. [剑指 Offer 62. 圆圈中最后剩下的数字](#剑指-offer-62-圆圈中最后剩下的数字)19. [剑指 Offer 63. 股票的最大利润](#剑指-offer-63-股票的最大利润)20. [剑指 Offer 64. 求1+2+…+n](#剑指-offer-64-求12n)21. [剑指 Offer 65. 不用加减乘除做加法](#剑指-offer-65-不用加减乘除做加法)22. [剑指 Offer 66. 构建乘积数组](#剑指-offer-66-构建乘积数组)23. [剑指 Offer 67. 把字符串转换成整数](#剑指-offer-67-把字符串转换成整数)24. [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](#剑指-offer-68---i-二叉搜索树的最近公共祖先)25. [剑指 Offer 68 - II. 二叉树的最近公共祖先](#剑指-offer-68---ii-二叉树的最近公共祖先)</code></pre><ol><li><a href="#完结散花-">完结散花 <del>~</del></a></li></ol><!-- /TOC --><h2 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a>剑指 Offer 50. 第一个只出现一次的字符</h2><p>遍历字符串，搞个map记录字符出现次数。再次遍历字符串，遇到出现次数为 1 的就返回。</p><h2 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a>剑指 Offer 51. 数组中的逆序对</h2><p>这题值得hard难度。<br>如果暴力解法，时间复杂度将是O(N^2)。比排序的O(NlogN)还大，那么可否先排序在比较，降低复杂度？<br>比如 [7, 5, 6, 4]   </p><ol><li>先均分为两部分 [7, 5] 和 [6, 4]，分别排序得到，[5, 7] 和 [4, 6]。</li><li>对于5，发现只比4大，说明只有一个[5, 4]，对于7，继续与6比较，而不用继续跟4比较，说明有[7, 4]、[7, 6] 两个。</li><li>继续分别针对[7，5] 和 [6, 4] 重复 <code>均分-&gt;排序-&gt;比较</code> 这个过程。分别只有一个结果[7, 5]和[6, 4]。</li><li>所以最终结果为 5 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 比较两个排好序的子数组</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">computePairs</span><span class="params">(arr1: List[int], arr2: List[int])</span> -&gt; int:</span></span><br><span class="line">            <span class="keyword">if</span> len(arr1) == <span class="number">0</span> <span class="keyword">or</span> len(arr2) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l = <span class="number">0</span></span><br><span class="line">            r = <span class="number">0</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> l&lt;len(arr1) :</span><br><span class="line">                <span class="keyword">while</span> r &lt; len(arr2) <span class="keyword">and</span> arr1[l] &gt; arr2[r]:</span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">                res += r</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 划分 &amp; 排序</span></span><br><span class="line">        nums2 = nums.copy()</span><br><span class="line">        left_arr = nums[:len(nums2)//<span class="number">2</span>]</span><br><span class="line">        right_arr = nums[len(nums2)//<span class="number">2</span>:]</span><br><span class="line">        left_arr.sort()</span><br><span class="line">        right_arr.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算本身结果，并递归子数组</span></span><br><span class="line">        <span class="keyword">return</span> computePairs(left_arr, right_arr) \</span><br><span class="line">               + self.reversePairs(nums[:len(nums)//<span class="number">2</span>]) \</span><br><span class="line">               + self.reversePairs(nums[len(nums)//<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a>剑指 Offer 52. 两个链表的第一个公共节点</h2><p>最简单的，先计算长度，然后比较两者的长度差，再利用快慢指针。<br>一个巧妙的办法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        c1 = headA</span><br><span class="line">        c2 = headB</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 最终c1和c2走的长度是相等的，LA + LB</span></span><br><span class="line">        <span class="comment"># 2. 如果不存在相交，c1走到B的结尾时会被赋值为None，此时c2也恰好走到A的结尾被赋值为None，刚好两者相等，跳出循环</span></span><br><span class="line">        <span class="keyword">while</span> c1 != c2:</span><br><span class="line">            c1 = c1.next <span class="keyword">if</span> c1 <span class="keyword">else</span> headB</span><br><span class="line">            c2 = c2.next <span class="keyword">if</span> c2 <span class="keyword">else</span> headA</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c1</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h2><p>先二分查找位置，再左右扩展。复杂度最差 O(N)，平均 O(logN) + O(M)。M为结果个数。如果M==N，则平均复杂度退化为 O(logN) + O(N)<br>再优化一下，可以先查左边界，再查右边界。就是 O(logN) 的复杂度，避免了最差O(N)的复杂度。   </p><p>都比暴力解法强吧 [doge][doge] </p><h2 id="指-Offer-53-II-0～n-1中缺失的数字"><a href="#指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="指 Offer 53 - II. 0～n-1中缺失的数字"></a>指 Offer 53 - II. 0～n-1中缺失的数字</h2><p>规律是：在缺失数左侧，每个数与其索引是相等的；在缺失数右侧，每个数 &gt; 其索引。因此可利用二分查找缺失数的位置。</p><h2 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a>剑指 Offer 54. 二叉搜索树的第k大节点</h2><p>按 <code>右子树 -&gt; 根 -&gt; 左子树</code> 的顺序遍历，使用全局变量记录还需遍历多少个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 返回</span></span><br><span class="line">        <span class="comment"># 1. 是否找到</span></span><br><span class="line">        <span class="comment"># 2. 对应的值</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(r: TreeNode)</span> -&gt; (bool, int):</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>, <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历右子树</span></span><br><span class="line">            found, val = dfs(r.right)</span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                <span class="keyword">return</span> found, val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历根</span></span><br><span class="line">            <span class="keyword">if</span> self.nk == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, r.val</span><br><span class="line">            self.nk -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历左子树</span></span><br><span class="line">            <span class="keyword">return</span> dfs(r.left)</span><br><span class="line"></span><br><span class="line">        self.nk = k</span><br><span class="line">        _, v = dfs(root)</span><br><span class="line">        <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a>剑指 Offer 55 - I. 二叉树的深度</h2><p>DFS，<code>Depth(root) = 1 + max(Depth(root.left), Depth(root.right))</code></p><h2 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a>剑指 Offer 55 - II. 平衡二叉树</h2><ol><li>解法一：计算并检查每一个节点左右子树的深度，但是这样做会有很多的重复计算。</li><li>解法二：自底向上，同时记录当前子树的深度，从而在计算父节点的深度时，避免重复计算。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -1 表示非平衡，直接返回</span></span><br><span class="line"><span class="comment"># &gt;=0 表示树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(root: TreeNode)</span> -&gt; (int):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = valid(root.left)</span><br><span class="line">    <span class="keyword">if</span> left == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    right = valid(root.right)</span><br><span class="line">    <span class="keyword">if</span> right == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> abs(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> valid(root) != <span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a>剑指 Offer 56 - I. 数组中数字出现的次数</h2><ol><li>如果一个数组中，只有一个数字出现了一次，其他数字都出现了两次，那么可以通过对所有数字进行xor操作，最后得到的就是该数</li><li>如果有两个数字a, b出现了一次，可以想办法将这两个数字划分到两个子数组，这两个子数组除下a, b外，其他都出现了两次，则可直接根据上述规律，xor遍历一遍得到a, b<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        xor_res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">            xor_res = xor_res ^ v</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找xor_res为1的那一位</span></span><br><span class="line">        <span class="comment"># 也就是res1 和 res2 不同的那一位</span></span><br><span class="line">        div = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (xor_res &amp; div) == <span class="number">0</span>:</span><br><span class="line">            div = div &lt;&lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        xor1 = <span class="number">0</span></span><br><span class="line">        xor2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> v &amp; div == <span class="number">0</span>:</span><br><span class="line">                xor1 = xor1 ^ v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                xor2 = xor2 ^ v</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [xor1, xor2]</span><br></pre></td></tr></table></figure></li></ol><h2 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a>剑指 Offer 56 - II. 数组中数字出现的次数 II</h2><ol><li>解法一：遍历统计每个bit 1 出现的次数，最后对 3 取模即可。</li><li>解法二：还有个位运算的解，感觉没必要这么取巧。</li></ol><h2 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a>剑指 Offer 57 - II. 和为s的连续正数序列</h2><p>滑动窗口，<code>[i, j]</code>表示连续子数组的两端，临时sum &lt;&gt; s，j右移扩大窗口，否则 i 左移缩小窗口。</p><h2 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a>剑指 Offer 58 - I. 翻转单词顺序</h2><p>split一下，然后倒序数组，最后拼接。</p><h2 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a>剑指 Offer 58 - II. 左旋转字符串</h2><p>切片操作，不做赘述。</p><h2 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a>剑指 Offer 59 - I. 滑动窗口的最大值</h2><p>这题标记为 easy 过分了。<br>暴力解法就不说了，时间复杂度是 <code>O(k*N)</code>。<br>可以优化一下，使用单调减的辅助队列（类似单调栈），来减少求每个窗口最大值时的遍历情况。复杂度为O(N)，因为辅助队列里的每个数，平均跟新进入队列的数，比较1次。（因为要么直接加入队列，要么，删掉队尾比它小元素，加入队列），被删掉的元素只会被比较 1 次。<br>考虑极端情况，每个数都会加入辅助队列（原数组是递减的），则每次仍只需比较队尾元素和新加入元素 1 次。因此比较了 2N 次<br>PS：单调栈和单调队列，是一个非常有帮助的思路。</p><h2 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a>剑指 Offer 59 - II. 队列的最大值</h2><p>类似 <a href="#剑指-offer-30-包含min函数的栈">剑指 Offer 30. 包含min函数的栈</a>，同样使用单调减的辅助队列。这题也可以称为”包含max函数的队列“。</p><h2 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a>剑指 Offer 60. n个骰子的点数</h2><p>这个题目描述得实在不好理解。</p><blockquote><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p></blockquote><p>不过，写到这里，我发现用文字去描述一个算法思想，确实不太容易。<br>至于这题，举个栗子，比如两个骰子，那么依次输出，抛出骰子的和为 2、3、4、5、6 …的概率。</p><p>首先可知，有 n 个骰子，那么结果范围为 [n, 6*n]，那么利用动态规划思想：</p><ol><li>划分子问题：使用n个骰子抛出 x 的概率，等于使用一个骰子抛出 a 的概率 乘以 n-1 个骰子，抛出 x-a 的概率。一个骰子抛出各个值的概率自然是 1/6</li><li>状态转移公式：dp(n, x) = 1/6 * dp(n, x-a), 其中 a in [1, 6]</li><li>边界条件：dp(1, a) = 1/6，其中 a in [1, 6]</li></ol><h2 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a>剑指 Offer 61. 扑克牌中的顺子</h2><p>除下0之外，数组不能重复。同时计算数组的最小值、最大值。（除 0 以外）<br>判断 <code>max_val - min_val</code> 是否 &lt;= 4。 </p><h2 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a>剑指 Offer 62. 圆圈中最后剩下的数字</h2><p>约瑟夫环，这特么竟然标记为<strong>简单！！！</strong> 说是<code>hard</code>真不算过分。<br>因为输出是最后剩下的数字，也正好是其下标。<br>约瑟夫环的关键在于递推公式:    </p><blockquote><p><code>F(N, M) = (F(N-1, M) + M) % N</code>   </p></blockquote><p>其中，<code>F(N,M)</code>表示 N 个人时，某未被删除的数字的下标。<br>假设 <code>F(N,M) = y</code>，在经过一次删除操作后，y的下标变为了 <code>(y-M)%(N-1)</code>，即 F(N-1, M)，设为 x。<br>（因为 N 个数时，删除 M，会从第 M+1 处重新从 0 计算下标。被删除的 M 处于新数组的队尾，因此不会因为空洞之类的原因，影响新的下标计算。）<br>根据   </p><blockquote><p><code>(y-M)%(N-1)=x</code>   </p></blockquote><p>可推得：</p><blockquote><p> <code>y = (x + M) % N</code>   </p></blockquote><p>其实也好理解，相当于删除的逆过程，x左移M个位置，然后对N取余。</p><p>已知，F(1, M) = 0，因为1个人的时候，剩下数字的下标就是 0，那么可以递推出 F(1, M)，F(2, M) 直到 F(N, M)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int, m: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (m + self.lastRemaining(n<span class="number">-1</span>, m)) % n</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a>剑指 Offer 63. 股票的最大利润</h2><p>这个显然算 easy，却标记为 middle。不再啰嗦。</p><h2 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a>剑指 Offer 64. 求1+2+…+n</h2><p>这个妙在，利用 and / or 操作的执行顺序。已知：</p><blockquote><p>A and B，如果 A 为false，则 B 不会再执行<br>  A or B，如果 A 为true，则 B 不会再执行</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNums</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(n: int)</span>:</span></span><br><span class="line">            _ = n != <span class="number">1</span> <span class="keyword">and</span> self.sumNums(n - <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># _ = n == 1 or self.sumNums(n - 1)</span></span><br><span class="line">            self.res += n</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        sum(n)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a>剑指 Offer 65. 不用加减乘除做加法</h2><p>这个特么又标为easy就离谱，里面的细节一点不少。<br>两个数的相加，在二进制上可以表现为两部分：   </p><ol><li>直接相加，忽略进位：s1 = a ^ b，相同为0，不同为1 </li><li>进位部分：s2 = (a &amp; b) &lt;&lt; 1，同为1的位，要向左进一位</li><li>两部分相加：sum = s1 + s2</li></ol><h2 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a>剑指 Offer 66. 构建乘积数组</h2><p>使用两个辅助数组，分别计算从左到右，以及从右至左的乘积。<br>再优化一下，可以只使用一个辅助数组。</p><h2 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a>剑指 Offer 67. 把字符串转换成整数</h2><p>难点在于检查中间结果是否溢出的条件，两种情况：</p><ol><li><code>res &gt; INT_MAX // 10</code>，此时 res * 10，肯定溢出了   </li><li><code>res == INT_MAX // 10 and cur_num &gt; 7</code>，因为INT_MAX = 2147483647，如果 res 是正数，显然越界；如果 res 是负数，INT_MIN = -2147483648，所以满足这个条件的，只有 INT_MIN 本身。</li></ol><h2 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h2><p>先分析下问题：</p><ol><li>如果 p == root 或 q == root，那么 root 本身就是最近公共祖先</li><li>如果 p &lt; root &lt; q，那root一定是最近公共祖先</li><li>如果不满足 1，那么p和q 一定同时在 root 的左子树或右子树   </li></ol><p>上述root可能是某棵子树的根节点。</p><h2 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a>剑指 Offer 68 - II. 二叉树的最近公共祖先</h2><p>先分析下问题：   </p><ol><li>这是一棵普通二叉树，非搜索二叉树，各节点是无序的</li><li>最近公共祖先的定义不变，对于某节点来说，p/q 分别位于其左右子树；或其为p或q，并且q或p在其子树上；该节点就是最近公共祖先。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 你可能有疑问，不用确定另一个在不再它的子树里吗？无需确定</span></span><br><span class="line">        <span class="comment"># 假如root=p，若q在其子树里，root即为最近公共祖先；</span></span><br><span class="line">        <span class="comment"># 若q不在其子树里，那一定在别的子树里，此时会有left_res和right_res都不为None的时候，也就会返回对应的root</span></span><br><span class="line">        <span class="keyword">if</span> root.val == p.val <span class="keyword">or</span> root.val == q.val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        left_res = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right_res = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="comment"># p, q分别位于root的左右子树，root本身就是解</span></span><br><span class="line">        <span class="keyword">if</span> left_res <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right_res <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 到这里，left_res 和 right_res 一个为None，一个不为None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 情况1：某子树root==p或q，因此返回了自己，此时最近公共祖先，就是该子树的root。</span></span><br><span class="line">        <span class="comment"># 就是left_res或right_res中不为空的那个。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况2：某棵子树上发现了最近公共祖先，将其传递至最上层</span></span><br><span class="line">        <span class="keyword">return</span> left_res <span class="keyword">if</span> left_res <span class="keyword">else</span> right_res</span><br></pre></td></tr></table></figure><h1 id="完结散花"><a href="#完结散花" class="headerlink" title="完结散花 ~"></a>完结散花 <del>~</del></h1><p><img src="/images/jian_zhi_offer.jpg" alt="abc"></p>]]></content>
    
    <summary type="html">
    
      剑指offer 51-75 题，思路简结
    
    </summary>
    
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题目思路简结-2</title>
    <link href="http://yoursite.com/2020/06/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93-2/"/>
    <id>http://yoursite.com/2020/06/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93-2/</id>
    <published>2020-06-22T13:43:53.000Z</published>
    <updated>2020-06-22T13:43:53.000Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ol><li><a href="#剑指-offer-26-树的子结构">剑指 Offer 26. 树的子结构</a></li><li><a href="#剑指-offer-27-二叉树的镜像">剑指 Offer 27. 二叉树的镜像</a></li><li><a href="#剑指-offer-28-对称的二叉树">剑指 Offer 28. 对称的二叉树</a></li><li><a href="#剑指-offer-29-顺时针打印矩阵">剑指 Offer 29. 顺时针打印矩阵</a></li><li><a href="#剑指-offer-30-包含min函数的栈">剑指 Offer 30. 包含min函数的栈</a></li><li><a href="#剑指-offer-31-栈的压入弹出序列">剑指 Offer 31. 栈的压入、弹出序列</a></li><li><a href="#剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</a></li><li><a href="#剑指-offer-32---ii-从上到下打印二叉树-ii">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></li><li><a href="#剑指-offer-32---iii-从上到下打印二叉树-iii">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></li><li><a href="#剑指-offer-33-二叉搜索树的后序遍历序列">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></li><li><a href="#剑指-offer-34-二叉树中和为某一值的路径">剑指 Offer 34. 二叉树中和为某一值的路径</a></li><li><a href="#剑指-offer-35-复杂链表的复制">剑指 Offer 35. 复杂链表的复制</a></li><li><a href="#剑指-offer-36-二叉搜索树与双向链表">剑指 Offer 36. 二叉搜索树与双向链表</a></li><li><a href="#剑指-offer-37-序列化二叉树">剑指 Offer 37. 序列化二叉树</a></li><li><a href="#剑指-offer-38-字符串的排列">剑指 Offer 38. 字符串的排列</a></li><li><a href="#剑指-offer-39-数组中出现次数超过一半的数字">剑指 Offer 39. 数组中出现次数超过一半的数字</a></li><li><a href="#剑指-offer-40-最小的k个数">剑指 Offer 40. 最小的k个数</a></li><li><a href="#剑指-offer-41-数据流中的中位数">剑指 Offer 41. 数据流中的中位数</a></li><li><a href="#剑指-offer-42-连续子数组的最大和">剑指 Offer 42. 连续子数组的最大和</a></li><li><a href="#剑指-offer-43-1n整数中1出现的次数">剑指 Offer 43. 1～n整数中1出现的次数</a></li><li><a href="#剑指-offer-44-数字序列中某一位的数字">剑指 Offer 44. 数字序列中某一位的数字</a></li><li><a href="#剑指-offer-45-把数组排成最小的数">剑指 Offer 45. 把数组排成最小的数</a></li><li><a href="#剑指-offer-46-把数字翻译成字符串">剑指 Offer 46. 把数字翻译成字符串</a></li><li><a href="#剑指-offer-47-礼物的最大价值">剑指 Offer 47. 礼物的最大价值</a></li><li><a href="#剑指-offer-48-最长不含重复字符的子字符串">剑指 Offer 48. 最长不含重复字符的子字符串</a></li><li><a href="#剑指-offer-49-丑数">剑指 Offer 49. 丑数</a></li></ol><!-- /TOC --><h2 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a>剑指 Offer 26. 树的子结构</h2><p>DFS判断各个子树，是否满足子树条件即可。<br><strong>树的结构，天生适合递归。</strong></p><h2 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a>剑指 Offer 27. 二叉树的镜像</h2><p>递归交换左右子树的左右节点。</p><h2 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a>剑指 Offer 28. 对称的二叉树</h2><p>递归判断左右子树的左右节点。</p><h2 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a>剑指 Offer 29. 顺时针打印矩阵</h2><p>像洋葱一样，一层一层剥离打印。注意一些特殊情况，比如矩阵只有一行、一列的情况</p><h2 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a>剑指 Offer 30. 包含min函数的栈</h2><p>关键在于min的复杂度要求O(1)。这里需要用一个单调递减的栈，辅助实现。<br><strong>单调栈、单调队列在处理一些栈、队列最大值、最小值上很有用。</strong></p><h2 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a>剑指 Offer 31. 栈的压入、弹出序列</h2><p>用一个栈去模拟压入、弹出过程，每当pop[0]==stack[-1]时，stack就弹出。<br>如果模拟完后，stack里还有数，则说明序列不对。</p><h2 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a>剑指 Offer 32 - I. 从上到下打印二叉树</h2><p>类似BFS，使用一个队列保存当前level的节点，之后依次遍历。   </p><h2 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a>剑指 Offer 32 - II. 从上到下打印二叉树 II</h2><p>类似 <a href="#剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</a>，每层的结果单独保存即可。</p><h2 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a>剑指 Offer 32 - III. 从上到下打印二叉树 III</h2><p>类似 <a href="#剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</a>，每层的结果单独保存即可。使用一个flag来判断顺序还是逆序。</p><h2 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a>剑指 Offer 33. 二叉搜索树的后序遍历序列</h2><p>根据root节点，划分左右子树，递归判对即可。</p><h2 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a>剑指 Offer 34. 二叉树中和为某一值的路径</h2><p>递归DFS</p><h2 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a>剑指 Offer 35. 复杂链表的复制</h2><p>这题有意思，难得见到一个有意思的链表类的题。思路步骤：   </p><ol><li>复制：对每个节点都复制一个节点，并添加在其后面</li><li>拆分：对复制后的链表进行拆分，由于已知每个节点后面跟的，都是其复制节点，因此只需将复制节点的指向，也指向对应节点的复制节点，即可。</li></ol><h2 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a>剑指 Offer 36. 二叉搜索树与双向链表</h2><p>对二叉搜索树模拟中序遍历，用一个指针记录遍历过程中的pre节点，最后将首尾相连，即可。</p><h2 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a>剑指 Offer 37. 序列化二叉树</h2><p>这题标记为hard，但实际上应该只算得上middle。   </p><ol><li>序列化：类似层次遍历，与 <a href="#剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</a> 相似。   </li><li>反序列化：还是模拟层次遍历的过程</li></ol><h2 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a>剑指 Offer 38. 字符串的排列</h2><p>这种排列组合、枚举类题，都可以用回溯思想来解决。和DFS类似，其实DFS是回溯思想在树、图之类的特殊场景里的一种表现。同DFS，回溯的常见实现方式也是递归。<br><strong>递归的时候，要小心大量的重复计算。（动态规划的递归实现中也存在）</strong> 通常要进行剪枝操作。因此也和动态规划的实现类似，可以使用备忘录法，或自底向上法。自底向上法效率最高，因为常常可以用循环迭代方式实现，减少递归调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 递归回溯，执行时间700ms</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation1</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line"></span><br><span class="line">        res = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            child_res = self.permutation1(s[:i] + s[i + <span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> child_res:</span><br><span class="line">                res.add(s[i] + v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 备忘录，执行时间120ms</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation2</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        seen = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">perm</span><span class="params">(s2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(s2) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s2 <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> seen[s2]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归过程不变</span></span><br><span class="line">            res = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s2)):</span><br><span class="line">                child_res = perm(s2[:i] + s2[i + <span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> child_res:</span><br><span class="line">                    res.add(s2[i:i + <span class="number">1</span>] + v)</span><br><span class="line"></span><br><span class="line">            seen[s2] = list(res)</span><br><span class="line">            <span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line">        sorted_s = <span class="string">''</span>.join(sorted(s))</span><br><span class="line">        <span class="keyword">return</span> perm(sorted_s)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自底向上，执行时间80ms</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation3</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line"></span><br><span class="line">        res = set(s[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s[<span class="number">1</span>:]:</span><br><span class="line">            new_set = set()</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(item)+<span class="number">1</span>):</span><br><span class="line">                    new_item = item[<span class="number">0</span>:i] + c + item[i:]</span><br><span class="line">                    new_set.add(new_item)</span><br><span class="line">            res = new_set</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a>剑指 Offer 39. 数组中出现次数超过一半的数字</h2><p>遍历一遍数组，记录一个数x，及其出现次数，遇见相同的数，次数加一，遇见不同的数，次数减一。如果次数减到0，则x=新的数。遍历完成后，x即为次数超过一半的数字。</p><h2 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a>剑指 Offer 40. 最小的k个数</h2><p>经典题目，两种解法：</p><ol><li>利用容量为K的大顶堆，遍历一遍即可，比堆顶元素小的入堆，容量超过K时出堆</li><li>利用快排的二分思路，每次可以排除一批不满足条件的数，从而快速缩小查找范围   </li></ol><p>解法的关键思想在于，<strong>找最小的k个数，但是这k个数互相是不必排序的，因此尽力减少这部分比较操作</strong>。堆就减少了内部各个元素互相排序的操作。同样快排的二分思想，也可以一下子找到最大的m个数，m取决于所选的pivot。但是这m个数只需跟pivot比较，相互之间无需比较。</p><h2 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a>剑指 Offer 41. 数据流中的中位数</h2><p>这个有点妙。   </p><ol><li>使用两个堆，一个使用小顶堆，保存较大的一半数字；一个使用大顶堆，保存较小的一半数字。同时保持两个堆的元素数量相对平衡 <code>0 &lt;= (大堆-小堆) &lt; 1</code>。此时两个堆的堆顶元素，就是数据流中间的两个数。</li><li>在push时，将其和堆顶元素比较选一个堆加入。如果加入后，两个堆失去平衡，则进行调整</li><li>取中位数时，根据两个堆元素数是否相等可知，一共有奇数或偶数个数字。从而根据堆顶元素，计算中位数。</li></ol><h2 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a>剑指 Offer 42. 连续子数组的最大和</h2><p>对于每一个元素，有两个选择，与前一个数字组成子数组，或重新开始计算子数组。<br>记录遍历过程中的最大值。</p><h2 id="剑指-Offer-43-1～n整数中1出现的次数"><a href="#剑指-Offer-43-1～n整数中1出现的次数" class="headerlink" title="剑指 Offer 43. 1～n整数中1出现的次数"></a>剑指 Offer 43. 1～n整数中1出现的次数</h2><p>按个位、十位、百位…考虑，比如：输入314，分析过程如下   </p><ol><li>个位4，&gt;1，高位为31，受此影响，有 32 * 1 = 32 种可能</li><li>十位1，=1，高位为3，低位为4，受此影响，有 3*10 + 5 = 35 种可能</li><li>百位3，&gt;1，高位为0，受此影响，有 1*100 = 100 种可能   </li></ol><p>因此一共 32 + 35 + 100 = 167个。关键在于梳理清各种情况下1的个数。<br>比如十位为1时，那么有01x/11x/21x，以及310~314，这么多种，也就是 3*10+5 = 35种。<br>对于百位，当百位为1时，有1xx这么多种情况，所以就是 1 * 100种。</p><h2 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a>剑指 Offer 44. 数字序列中某一位的数字</h2><p>和 <a href="#剑指-offer-43-1n整数中1出现的次数">剑指 Offer 43. 1～n整数中1出现的次数</a> 类似，关键在于找规律。可以发现:<br>忽略0<br>数字为1位的，从 1 开始，一共 9 个，1 - 9<br>数字为2位的，从 10 开始，一共 90 个，10 - 99<br>数字为3位的，从 100 开始，一共 900 个，100 - 999<br>…<br>依此可确定，第n位所在的区间，在取模可得到具体是哪个数字。大致思想如上，实现细节不再赘述。</p><h2 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a>剑指 Offer 45. 把数组排成最小的数</h2><p>一个取巧的办法，对数组进行自定义排序，从小到大。对于a、b两数的比较规则是，如果ab&gt;ba，则a&gt;b，否则a&lt;b。   </p><h2 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a>剑指 Offer 46. 把数字翻译成字符串</h2><p>按动态规划的方式比较好理解：</p><ol><li>划分子问题：每一位数字，既可以单独表示一个字母，也可以与后面数字组合，共同表示一个字母，如果&lt;26的话。</li><li>状态转移公式：F(s) = F(s[1:]) + F(s[2:])</li><li>边界条件：len(s)&lt;=1时，F(s) = 1; 为什么 s 是空字符串时，F(s)也=1呢，s为空字符串，表示刚好划分完，仅此一种。比如12，F(12) = F(2) + F(“”)，F(“”)表示，12作为一个整体解释。</li></ol><h2 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a>剑指 Offer 47. 礼物的最大价值</h2><p>很基础的动态规划题：<br>按动态规划的方式比较好理解：</p><ol><li>划分子问题：每一个格子可以分为，从上边格子和左边格子过来两种情况</li><li>状态转移公式：dp[i][j] = max(dp[i-1][j]+grid[i][j], dp[i][j-1]+grid[i][j])</li><li>边界条件：第一行和第一列，单独处理   </li></ol><p>另外可以发现，dp[i][j]只和上一行有关，因此为了降低空间复杂度，可以只用一行空间即可。对 M*N 的格子，空间复杂度可以从 O(M * N) 降低至 O(M) 或 O(N)</p><h2 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a>剑指 Offer 48. 最长不含重复字符的子字符串</h2><p>使用两个指针 i, j，分别表示起始和结束。同时记录、更新某字符上次出现的位置。<br>如果 j 指向的当前字符，上次出现的位置 k &gt; i，表示重复出现，则 i 更新为 k + 1。此时得到一个最长不重复子字符串，长度为 j-i。</p><h2 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a>剑指 Offer 49. 丑数</h2><p>下一个丑数为，当前丑数序列 * 2、3、5，得到的丑数中，最小的那个。<br>为了避免重复计算，可以使用三个数，分别记录上一个乘以2、3、5后，就大于最新丑数的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        a, b, c = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 计算下一个丑数</span></span><br><span class="line">            aN, bN, cN = dp[a] * <span class="number">2</span>, dp[b] * <span class="number">3</span>, dp[c] * <span class="number">5</span></span><br><span class="line">            <span class="comment"># 选最小的</span></span><br><span class="line">            next = min(aN, bN, cN)</span><br><span class="line">            dp[i] = next</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> next == aN:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> next == bN:</span><br><span class="line">                b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> next == cN:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      剑指offer 24-50 题，思路简结
    
    </summary>
    
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题目思路简结-1</title>
    <link href="http://yoursite.com/2020/06/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93-1/"/>
    <id>http://yoursite.com/2020/06/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93-1/</id>
    <published>2020-06-22T06:54:13.000Z</published>
    <updated>2020-06-22T06:54:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ol><li><a href="#剑指-offer-03数组中重复的数字">剑指 Offer 03.数组中重复的数字</a></li><li><a href="#剑指-offer-04-二维数组中的查找">剑指 Offer 04. 二维数组中的查找</a></li><li><a href="#剑指-offer-05-替换空格">剑指 Offer 05. 替换空格</a></li><li><a href="#剑指-offer-06-从尾到头打印链表">剑指 Offer 06. 从尾到头打印链表</a></li><li><a href="#剑指-offer-07-重建二叉树">剑指 Offer 07. 重建二叉树</a></li><li><a href="#剑指-offer-09-用两个栈实现队列">剑指 Offer 09. 用两个栈实现队列</a></li><li><a href="#剑指-offer-10--i-斐波那契数列">剑指 Offer 10- I. 斐波那契数列</a></li><li><a href="#剑指-offer-10--ii-青蛙跳台阶问题">剑指 Offer 10- II. 青蛙跳台阶问题</a></li><li><a href="#剑指-offer-11-旋转数组的最小数字">剑指 Offer 11. 旋转数组的最小数字</a></li><li><a href="#剑指-offer-12-矩阵中的路径">剑指 Offer 12. 矩阵中的路径</a></li><li><a href="#剑指-offer-13-机器人的运动范围">剑指 Offer 13. 机器人的运动范围</a></li><li><a href="#剑指-offer-14--i-剪绳子">剑指 Offer 14- I. 剪绳子</a></li><li><a href="#剑指-offer-14--ii-剪绳子-ii">剑指 Offer 14- II. 剪绳子 II</a></li><li><a href="#剑指-offer-15-二进制中1的个数">剑指 Offer 15. 二进制中1的个数</a></li><li><a href="#剑指-offer-16-数值的整数次方">剑指 Offer 16. 数值的整数次方</a></li><li><a href="#剑指-offer-17-打印从1到最大的n位数">剑指 Offer 17. 打印从1到最大的n位数</a></li><li><a href="#剑指-offer-18-删除链表的节点">剑指 Offer 18. 删除链表的节点</a></li><li><a href="#剑指-offer-19-正则表达式匹配">剑指 Offer 19. 正则表达式匹配</a></li><li><a href="#剑指-offer-20-表示数值的字符串">剑指 Offer 20. 表示数值的字符串</a></li><li><a href="#剑指-offer-21-调整数组顺序使奇数位于偶数前面">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></li><li><a href="#剑指-offer-22-链表中倒数第k个节点">剑指 Offer 22. 链表中倒数第k个节点</a></li><li><a href="#剑指-offer-24-反转链表">剑指 Offer 24. 反转链表</a></li><li><a href="#剑指-offer-25-合并两个排序的链表">剑指 Offer 25. 合并两个排序的链表</a></li></ol><!-- /TOC --><h2 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03.数组中重复的数字"></a>剑指 Offer 03.数组中重复的数字</h2><p>直接使用hash即可，高级一点的使用bitmap也可</p><h2 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h2><p>关键在于，利用规律缩小查找范围。   </p><ol><li>如果target &lt; 当前的数，那么它就不可能在target同一行的左边</li><li>每一列都按照从上到下递增的顺序排序：那么如果target &gt; 当前的数，那么它就不可能在target同一列的上面  </li></ol><p>从右上角开始找，一点一点缩小范围。</p><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><ol><li>如果用python/java/golang之类的，可以直接拼接字符串。动态分配内存。   </li><li>如果用c/c++，就需要预分配内存，因此需要先遍历一遍，计算有多少个空格，从而计算结果字符串所需内存大小。</li></ol><h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h2><ol><li>解法一：先遍历，再对结果数组反转</li><li>解法二：使用栈暂存节点，然后弹出栈 </li></ol><h2 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a>剑指 Offer 07. 重建二叉树</h2><p>关键点：</p><ol><li>前序遍历的第一个节点，是当前节点的root；但是没法区分剩余节点，哪些是左、右子树</li><li>根据root，可以把中序遍历，分为左右子树两部分；借此得知左右子树的节点数量，也就能把前序遍历剩余节点分开</li><li>对前序遍历拆分的左右子树，递归求解</li></ol><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h2><p>关键点：</p><ol><li>两个栈，一个是input栈，一个是output栈，分别只负责input和output</li><li>output没了，就从input里转移到output   </li></ol><p>时间复杂度，O(1)；空间复杂度，O(n)</p><h2 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h2><p>递归、迭代解法，不再赘述。<br>值得一提的是，对于递归类题目，有两个关键点：</p><ol><li>递归子问题</li><li>递归终止条件，这个不能忘，否则会stackoverflow   </li></ol><p>尤其是二叉树类的问题，天生合适递归。把一个二叉树的问题，转换为，分别针对左右子树的两个子问题。</p><h2 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a>剑指 Offer 10- II. 青蛙跳台阶问题</h2><p>同 <a href="#剑指-offer-10--i-斐波那契数列">剑指 Offer 10- I. 斐波那契数列</a> 斐波那契数列。</p><h2 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a>剑指 Offer 11. 旋转数组的最小数字</h2><p>二分法，确定min_index在[left, mid]，还是在[mid, right]之间。注意下极端条件，比如：翻转0个的情况；所有数都相等的情况；最后剩余两个数的情况；mid和边界相等的情况等等</p><h2 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a>剑指 Offer 12. 矩阵中的路径</h2><p>DFS</p><h2 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a>剑指 Offer 13. 机器人的运动范围</h2><p>BFS，当然DFS也可以，不过BFS最合适，相当于一圈一圈地扩展范围</p><h2 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a>剑指 Offer 14- I. 剪绳子</h2><p>简单的动态规划，顺带提一下动态规划的三个关键点：</p><ol><li>划分子问题：一个大问题可以拆分为多个子问题，并且在大问题是最优解时，拆分出来的子问题也都是最优解的状态。</li><li>状态转移公式</li><li>边界条件   </li></ol><p>是不是很像递归，因为动态规划一个最简单的实现方式就是递归。对于该题，三个关键点分别是：</p><ol><li>划分子问题：长度为n的绳子，最大乘积，等于将其分一部分、两部分、多部分的最大值。</li><li>状态转移公式：F(n) = max( (n-i) * F[i] for i in range(1, n))</li><li>边界条件：F(0) = 1; F(1) = 1   </li></ol><p>另外，由于该题要求至少分两段，因此需要对长度为最长时，稍微做一点特殊处理。</p><p>如果是递归实现，是会提示超时的，因为其中存在很多重复的计算。可以用递归的另外两种实现方式：备忘录法，自底向上法。</p><p>还有一种解法是根据数学规律，将n分为尽量多个3。这种解法不具通用性，就不介绍了。</p><h2 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a>剑指 Offer 14- II. 剪绳子 II</h2><p>在 <a href="#剑指-offer-14--i-剪绳子">剑指 Offer 14- I. 剪绳子</a> 基础上，多了大数，就直接使用long类型，然后取模吧。</p><h2 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a>剑指 Offer 15. 二进制中1的个数</h2><p>经典位运算题。n的每一位与 1 做 与操作，直到n变为0。</p><h2 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a>剑指 Offer 16. 数值的整数次方</h2><p>关键点，利用二分思想：   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pow(x, n) = pow(x, n//<span class="number">2</span>) ** <span class="number">2</span>  <span class="comment"># n为偶数   </span></span><br><span class="line">pow(x, n) = pow(x, n//<span class="number">2</span>) ** <span class="number">2</span> * x  <span class="comment"># n为奇数</span></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a>剑指 Offer 17. 打印从1到最大的n位数</h2><p>最大的n位数，是 pow(10, n)-1，遍历即可。<br>小心大数越界，如果是面试。</p><h2 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h2><p>不再赘述。<br>值得一提：链表类问题，可以增加一个头结点dummy_head，这样可以使边界情况，处理起来方便很多。</p><h2 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a>剑指 Offer 19. 正则表达式匹配</h2><p>动态规划：（主串S, 模式串T）   </p><ol><li><p>划分子问题：如果S和T匹配，那么S和T的子串也匹配</p></li><li><p>状态转移公式：<br>为了避免每次都要检查，后一个字符串是否是”*”，从后往前遍历。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. T[i] 是普通字符</span><br><span class="line">    F(S, T) &#x3D; S[i] &#x3D;&#x3D; T[i] &amp;&amp; F(S[:-1], T[:-1])</span><br><span class="line"></span><br><span class="line">2. T[i] &#x3D;&#x3D; &#39;.&#39;，可以匹配任何字符</span><br><span class="line">    F(S, T) &#x3D; F(S[:-1], T[:-1])</span><br><span class="line"></span><br><span class="line">3. T[i] &#x3D;&#x3D; &#39;*&#39;，*前面的字符可以重复0次或多次</span><br><span class="line">    </span><br><span class="line">    3.1 S&#x3D;&#x3D;&quot;&quot;, 说明*前面的字符重复0次</span><br><span class="line">        F(S, T) &#x3D; F(S, T[:-2])</span><br><span class="line"></span><br><span class="line">    3.2 T[-2] &#x3D;&#x3D; &#39;.&#39; 或 S[-1] &#x3D;&#x3D; T[-2]，前一个字符能匹配上，则需考虑匹配0次、和多次的情况</span><br><span class="line">        F[S, T] &#x3D; F(S, T[:-2]) || F(S[:-1], T)   </span><br><span class="line"></span><br><span class="line">    3.3 S[-1] !&#x3D; T[-2]，前一个字符不匹配，相当于匹配了0次</span><br><span class="line">        F(S, T) &#x3D; F(S, T[:-2])</span><br></pre></td></tr></table></figure></li><li><p>边界条件:<br>边界条件，就是S、T一直递归匹配，直到某一个变为了空字符串</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. S &#x3D;&#x3D; &quot;&quot; &amp;&amp; T &#x3D;&#x3D; &quot;&quot;，return True</span><br><span class="line"></span><br><span class="line">2. S &#x3D;&#x3D; &quot;&quot; &amp;&amp; T !&#x3D; &quot;&quot;, 需要继续匹配，比如 S&#x3D;”“， T&#x3D;&quot;a*&quot;，是匹配的</span><br><span class="line"></span><br><span class="line">3. S !&#x3D; &quot;&quot; &amp;&amp; T &#x3D;&#x3D; &quot;&quot;, return False</span><br></pre></td></tr></table></figure></li></ol><h2 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a>剑指 Offer 20. 表示数值的字符串</h2><p>非常典型的一道<code>有限状态机</code>题，重点在于划分不同的状态，怕错不怕重复。状态之间的转移相对容易。</p><h2 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h2><p>两个指针，pre指针从头开始遍历，post指针指向尾。每次pre指向一个偶数，就将其与post交换，直到两指针相遇。</p><h2 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h2><p>快慢指针，不做赘述。</p><h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h2><p>三个指针，循环遍历即可。注意边界条件。</p><h2 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a>剑指 Offer 25. 合并两个排序的链表</h2><p>添加一个dummy头结点，然后对两个链表，执行类似一个归并排序的操作。</p>]]></content>
    
    <summary type="html">
    
      剑指offer 1-23 题，思路简结
    
    </summary>
    
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>人生的一些大道理</title>
    <link href="http://yoursite.com/2020/06/11/%E4%BA%BA%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%A7%E9%81%93%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/11/%E4%BA%BA%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%A7%E9%81%93%E7%90%86/</id>
    <published>2020-06-11T08:25:13.000Z</published>
    <updated>2020-06-11T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- 虽然明明没啥资格去说人生这种大事，毕竟我也是第一次经历，并且只经历了一种人生。   然鹅，还是想闲扯几句。也是看李笑来老师的书，说一下自己的想法。### 问题1. 工作，还是睡懒觉？首先，**单独就辛苦本身，不值得。** 如果你家财万贯，衣食无忧，房车不缺，干嘛非得让自己辛苦？即使你没有大富大贵，但对目前的生活还挺满意，也不想着去追求更加丰富、昂贵的东西啦，更加崇高的地位啦，那也没必要辛辛苦苦。这两种情况，自己对什么有兴趣，就去做什么，这就挺好的呗~简直是我的理想生活啊！然鹅，无论出于什么原因，**如果你想追求更好的，那辛苦就是值得的。**### 问题2. 生活是否公平？上帝是不公平的，付出了不一定有回报。   上帝是公平的，不付出，就一定没有回报。   哪怕买彩票，也得多买几次，才更容易中奖不是？人很少会后悔做了哪些事，但是常常后悔没做哪些事儿。   另外，高考真的是人生最公平、公正的一次。而且大学这个烙印将陪伴你终身。高中要好好学习啊，弟弟妹妹们。大学就无所谓，想做其他事就去做，别挂科就行。### 问题3. 你的，还是我的？街上碰到一个苹果，两个人同时看到了，这个苹果该属于谁呢？有人离得近，有人离得远，有人走过去，有人跑过去。不管怎样，先到达的那个有苹果吃。   同样，有人生来就离苹果近，有人生来跑得快，有人毅力强能坚持。谁会是最后的赢家？   我们不知道这个距离有多远，但是人生近百年，不是一场百米赛跑，而是一个马拉松。   苹果，强者得之。   所以，是我的。[doge]    --><p><img src="/images/kobe.jpeg" alt="">   </p><p><strong>Respect ！</strong></p>]]></content>
    
    <summary type="html">
    
      李笑来传话筒。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从CAS到无锁队列.md</title>
    <link href="http://yoursite.com/2020/06/03/%E4%BB%8ECAS%E5%88%B0%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/03/%E4%BB%8ECAS%E5%88%B0%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</id>
    <published>2020-06-03T09:24:15.000Z</published>
    <updated>2020-06-03T09:24:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无锁算法"><a href="#无锁算法" class="headerlink" title="无锁算法"></a>无锁算法</h2><p>多个线程读写同一内存，如何做到不加锁呢？其实没有那么高大上的算法在里面，实现无锁的前提是，硬件需支持”读取-更新-写入“的原子操作，比如 Test and Set, Fetch and Add, Compare and Swap等。<br>以Compare and Swap，也就是CAS为例，可以实现很多无锁的数据结构，无锁队列，无锁树，区别在于需要几次的CAS。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p><code>bool CAS(type* addr, type val_old, type val_new)</code><br>如果 addr 的值等于 val_old，就把它设置为 val_new，设置成功返回true，失败返回false。<strong>这个比较并赋值的操作，是一个原子操作。</strong></p><h2 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h2><p>我们使用一个单向链表，作为无锁队列的基础数据结构。利用CAS的原子性，来保证在push/pop，也就是在链表尾/头添加、删除节点时，不会出现多线程互相覆盖的问题。</p><p>直接看代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很久没写C/CPP，语法细节忘了不少，忽略忽略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    node* tail  <span class="comment">// 尾指针</span></span><br><span class="line">    node* head  <span class="comment">// 头指针</span></span><br><span class="line">&#125;* Q</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Q是队列，data是待push的节点</span></span><br><span class="line">Push(Q, data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> </span><br><span class="line">    &#123;</span><br><span class="line">        p = Q-&gt;tail;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">CAS</span><span class="params">(p-&gt;next, <span class="literal">NULL</span>, data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果此时p还是Q的tail，才能设置成功</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新Q的tail，如果此时tail还是p，才能设置成功。</span></span><br><span class="line">    <span class="comment">// 此时不用担心失败，因为如果此处不更新tail，其他线程拿到的总是旧的tail，</span></span><br><span class="line">    <span class="comment">// 其他线程在while循环中的CAS，会发现p-&gt;next!=NULL，就会失败, 一直处于while循环中</span></span><br><span class="line">    CAS(Q-&gt;tail, p, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Pop(Q)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> </span><br><span class="line">    &#123;</span><br><span class="line">        p = Q-&gt;head</span><br><span class="line">        <span class="keyword">if</span> CAS(Q-&gt;head, p, p-&gt;next) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于CAS会直接用新值覆盖旧值，为了保存旧值，所以每次都会先把旧值取出来。然后在设新值时，要判断旧值是否发生了变化。<br>那么以上实现有什么问题没？</p><ol><li><p>问题1，死循环<br>考虑一些意外的情况。对于Push，如果线程第一个CAS执行成功，在执行第二个CAS时宕掉。此时 tail 未更新，其他线程会发现tail.next总是不为空，因此就会陷入while死循环。</p></li><li><p>问题2，<strong>ABA问题</strong><br>比如，一个线程按序执行了 pop -&gt; push操作，而push的节点，恰巧复用了被pop节点同一块内存。因为此链表例子中，CAS比较的是内存地址，所以校验通过。而里面的值其实是发生了变化的，如果不校验里面的值，可能会认为节点未被改动。</p></li></ol><p>这两个问题如何解决呢？   </p><ol><li>死循环问题</li></ol><ul><li>关键：tail节点未更新，导致CAS(p-&gt;next, NULL, data) 总是失败，因此可以让每个线程发现这个问题后，自己去更新tail节点。</li></ul><ol start="2"><li>ABA问题   </li></ol><ul><li>节点增加计数器，每一次更新。计数的增减操作也需要原子化。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无锁数据结构的大致思想就是这样。<br>借助CAS，一个极端的想法，所有程序都可以做成无锁的。只需要对任何一个变量的读写，都使用CAS操作，失败则从头开始。此时，虽然实现了无锁，但是效率却是降低的，因此，无锁也有它的适用场景 — <strong>读多写少</strong>，因为此时CAS的冲突率比较小。<br>与CAS比较像的一个机制，是自旋锁。自旋锁总是在尝试<strong>加锁</strong>，而CAS总是在尝试<strong>比较-修改</strong>，都算是<strong>忙等</strong>机制。</p>]]></content>
    
    <summary type="html">
    
      从无锁思想到CAS，再到具体实现，以无锁队列为例。
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法思想" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>PathEscape与QueryEscape</title>
    <link href="http://yoursite.com/2020/05/29/PathEscape%E4%B8%8EQueryEscape/"/>
    <id>http://yoursite.com/2020/05/29/PathEscape%E4%B8%8EQueryEscape/</id>
    <published>2020-05-29T04:56:52.000Z</published>
    <updated>2020-05-29T04:56:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在给client种cookie时，发现个问题，种进去的加密cookie，解密时总报错。<br>原因是：golang中，对一个字符串做url转义有两个方法，<code>url.PathEscape()</code>和<code>url.QueryEscape</code>。但是两个方法的行为有些区别。两者混用导致，编码和解码后，和原始字符串不一致。</p><h3 id="1-举个例子，直接对比下效果"><a href="#1-举个例子，直接对比下效果" class="headerlink" title="1. 举个例子，直接对比下效果"></a>1. 举个例子，直接对比下效果</h3><p>以 + 和 空格 这两个字符为例。   </p><table><thead><tr><th align="center">待转义字符</th><th align="center">PathEscape</th><th align="center">QueryEscape</th><th align="center">PathUnEscape</th><th align="center">QueryUnEscape</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">+</td><td align="center">%2B</td><td align="center">+</td><td align="center">空格</td></tr><tr><td align="center">空格</td><td align="center">%20</td><td align="center">+</td><td align="center">空格</td><td align="center">空格</td></tr></tbody></table><h3 id="2-具体功能"><a href="#2-具体功能" class="headerlink" title="2. 具体功能"></a>2. 具体功能</h3><h4 id="2-1-PathEscape"><a href="#2-1-PathEscape" class="headerlink" title="2.1 PathEscape"></a>2.1 PathEscape</h4><p>对特殊字符串进行转义，以便其可以作为url路径的一部分。就是URL地址两个 / 之间的部分</p><h4 id="2-2-QueryEscape"><a href="#2-2-QueryEscape" class="headerlink" title="2.2 QueryEscape"></a>2.2 QueryEscape</h4><p>对特殊字符串进行转义，以便其可以作为url query的参数，也就是 ？后面那一串kv。</p><h4 id="2-3-对比"><a href="#2-3-对比" class="headerlink" title="2.3 对比"></a>2.3 对比</h4><ol><li><p>两者的共同点在于：都会将一些特殊字符，转义为<code>%AB</code>的形式。特殊字符的定义为，除<code>a-z，A-Z，0-9，- _ ~ · , / ; ?</code> 的字符。</p></li><li><p>不同点在于：对于一些特殊字符，转义行为不同。</p></li></ol><table><thead><tr><th align="center">字符</th><th align="center">PathEscpae</th><th align="center">QueryEscape</th></tr></thead><tbody><tr><td align="center">$</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">&amp;</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">+</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">:</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">=</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">@</td><td align="center">Y</td><td align="center">N</td></tr></tbody></table><p>具体的可参考RFC文档（URI、URL的两篇）和Golang的源码。（Golang源码更简单直接）</p><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><p>其他语言似乎没分得那么清，具体实现上也有一些区别，比如python/javascript，encode行为就和golang的不一致。总之，同一语言，如golang，QueryEscape编码后，一定要配合QueryUnEscape使用。</p><p>一些细节也不同，比如JS里的encodeURI和encodeURIComponent。可以理解为，encodeURI，是把参数当做一个完整的URI在编码，而encodeURIComponent是把参数当做URI的一个segment。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS里</span></span><br><span class="line"><span class="built_in">encodeURI</span>(<span class="string">"12+34 56"</span>)</span><br><span class="line">output: <span class="string">"12+34%2056"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">"12+34 56"</span>)</span><br><span class="line">output: <span class="string">"12%2B34%2056"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"http://www.ruanyifeng.com/blog/2010/02/url_encoding.html"</span></span><br><span class="line"><span class="built_in">encodeURI</span>(a)</span><br><span class="line">output: <span class="string">"http://www.ruanyifeng.com/blog/2010/02/url_encoding.html"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">encodeURIComponent</span>(a)</span><br><span class="line">output: <span class="string">"http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2010%2F02%2Furl_encoding.html"</span></span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol><li><a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/02/url_encoding.html</a></li><li><a href="https://tools.ietf.org/html/rfc1738" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1738</a></li><li><a href="https://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc3986</a></li></ol>]]></content>
    
    <summary type="html">
    
      搞懂PathEscape与QeuryEscape区别
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>关于工作的一些想法.md</title>
    <link href="http://yoursite.com/2020/05/28/%E5%85%B3%E4%BA%8E%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/28/%E5%85%B3%E4%BA%8E%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</id>
    <published>2020-05-28T06:36:40.000Z</published>
    <updated>2020-05-28T06:36:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- 0. 工作的目的1. 浮于表面，不用思考2. 重复性，还是不用思考 --><p>待写。。<br>result=0&amp;anchor=0&amp;bingtuanbi=0&amp;charac_name=%E6%B2%83%E5%BE%B7%E6%A0%BC&amp;charac_no=117433682&amp;diamond=4371&amp;exp=6606&amp;gold=1003834&amp;historyintegral=2436.498904671832&amp;is_online=0&amp;lastlogintime=1595660151&amp;lastlogouttime=1595665930&amp;level=38&amp;medalcount=18&amp;online_time=0&amp;passlevel=1&amp;picture=http%3A%2F%2Fthirdwx.qlogo.cn%2Fmmopen%2Fvi%5F32%2FDYAIOgq83eojwWvPjy432loicmIuI1sFz7k4O2sia9OwAeDYE3icsuwribo8USyToiblBy5ShMl8w6AaAtZVwEVsq4A%2F64&amp;ranking=0&amp;register_time=1518239196&amp;unionid=0&amp;weekintegral=2436.498904671832&amp;wuzibi=18&amp;xingyunbi=0&amp;<em>idip_req_id</em>=&amp;<em>idip_msg_id</em>=4601_1599365430_9.68.189.34_6693_19916590940</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- 0. 工作的目的

1. 浮于表面，不用思考

2. 重复性，还是不用思考 --&gt;

&lt;p&gt;待写。。&lt;br&gt;result=0&amp;amp;anchor=0&amp;amp;bingtuanbi=0&amp;amp;charac_name=%E6%B2%83%E5%BE%B7%E6%A0%B
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>常见web安全总结</title>
    <link href="http://yoursite.com/2020/05/25/%E5%B8%B8%E8%A7%81web%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/05/25/%E5%B8%B8%E8%A7%81web%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-25T08:20:55.000Z</published>
    <updated>2020-05-25T08:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XSS，跨站脚本攻击"><a href="#XSS，跨站脚本攻击" class="headerlink" title="XSS，跨站脚本攻击"></a>XSS，跨站脚本攻击</h3><p>XSS的根本原因是，前端页面被嵌入一些恶意代码，这些恶意代码可能通过不同途径，注入进来。根据不同注入途径（或着说方式），可以分为反射型、持久型。</p><ol><li>反射型XSS   </li></ol><ul><li>恶意伪造url -&gt; 骗取用户点击 -&gt; 页面从url取参数进行渲染。从而参数里的恶意代码被执行。</li><li>案例：微博hellosamy事件</li></ul><ol start="2"><li>持久性XSS   </li></ol><ul><li>在留言板、评论等场景提交恶意代码 -&gt; 后台未经处理，直接保存了前端提交的数据，-&gt; 再次访问或其他人访问时，前端展示相关内容，又把这些数据取出来进行渲染，从而恶意代码被执行。  </li><li>案例：微信公众号XSS事件</li></ul><ol start="3"><li><p>应对：</p><ol><li>用户提交的数据，入库前预处理，有很多xssfilter可选</li><li>前端拼接Html时，也要做充分转义</li><li>为了防止cookie盗用，重要的cookie设置http-only为true</li></ol></li><li><p>参考   </p><blockquote><p><code>https://tech.meituan.com/2018/09/27/fe-security.html</code></p></blockquote></li></ol><h3 id="CSRF，跨站请求伪造（英語：Cross-site-request-forgery）"><a href="#CSRF，跨站请求伪造（英語：Cross-site-request-forgery）" class="headerlink" title="CSRF，跨站请求伪造（英語：Cross-site request forgery）"></a>CSRF，跨站请求伪造（英語：Cross-site request forgery）</h3><p>本质是浏览器在发起请求时，会自动带上对应域名下的cookie。该特性可能导致，用户在访问恶意网站时，在用户不知不觉的情况下，触发一些携带了用户身份信息（cookie）的请求。如下图所示：<br><img src="/images/csrf.jpg" alt="CSRF示意图"></p><blockquote><ol><li>银行网站A，它以GET请求来完成银行转账的操作，如：<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a></li><li>危险网站B，它里面有一段HTML的代码如下：<pre><code class="html">　　<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">http://www.mybank.com/Transfer.php?toBankId</span>=<span class="string">11&amp;money</span>=<span class="string">1000</span>&gt;</span></code></pre></li><li>首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……</li></ol></blockquote><p>在访问危险网站B的之前，你已经登录了银行网站A，而B中的img以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取src指向的资源，结果银行网站服务器收到请求后，判断身份通过，所以就立刻进行转账操作……</p><p>该例子里，一方面是由于用户上了小网站，另一方面，不应该用GET请求去更新资源（更改账户）。因为像src/script等标签都是默认用GET获取资源，如果再对前端熟悉一些的，可能会想到jsonp，就是利用script标签实现的。<br>很多邮箱图片默认不展示，CSRF也是原因之一。当然还有很多其他的风险，这个可以单开一篇，开开脑洞。</p><ol><li><p>vs 跨域？<br>很多人会有疑问，浏览器不是有跨域限制吗，为什么还会出现在A页面，访问B服务器的情况。<br>答：<strong>浏览器还是会正常发出跨域请求</strong>，收到response后，会判断源和当前页面的源是否是属于同源，如果不属于，则需要根据<code>access-control-allow-origin</code>等header，判断server端是否允许跨域。   </p></li><li><p>应对<br>主要通过两个关键点：   </p><ol><li><p>虽然A网站可以向B服务器发GET请求，但是由于跨域限制，没法处理对应的response。<strong>因此一些更新资源的操作，最好用POST</strong>，更好的是使用restful风格。另一方面，也可以增加二次确认，比如引入验证码，实际上相当于一个动态的token，要求在真实的B页面才能拿到。</p></li><li><p>正规的浏览器，使用js对cookie访问时，也要求同源。因此<strong>可以在query里增加一些cookie里才有的信息，在服务端校验query和cookie里对应的参数，如果不一致则为恶意。</strong> 这种方法的缺点在于，要求前端页面和后端接口的域名一致，而现在流行前后端分离，往往部署得不一致，比如页面在<code>web.qq.com</code>，接口在<code>api.qq.com</code>。如果cookie种在根域名<code>qq.com</code>，则如果其他某个子页面abc.qq.com被xss攻击，再被窃取了cookie，则该方案也会失效。</p><p>其他的方法，还有增加referer，但是有的时候请求不带referer，比如非http协议页面发出的请求（ftp之类的）、https页面发出的http请求等，因此referer方案有一定的漏洞。</p></li></ol></li><li><p>参考</p><blockquote><p><code>https://juejin.im/post/6844903689702866952</code></p></blockquote></li></ol><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>关键点：<br>    1. 不要相信请求携带的参数，不要直接拿过来拼接SQL语句。<br>SQL注入的防范很成熟，使用prepare statement即可，常用的client lib里都会实现。但是表名不支持参数化，因此表名还是得使用代码拼接的方式。这就要求表名不能是前端输入的，或者增加表名白名单校验。   </p><blockquote><p>从一条sql执行过程来说，编译 -&gt; 执行。一般情况是连带参数，一起编译，就会出现注入情况。<br>  使用参数化查询的形式，会提前对模板进行预编译，而每个?占位的参数，只会被数据库当做一个完整的参数处理。</p></blockquote>]]></content>
    
    <summary type="html">
    
      总结常见的几种Web安全问题，包括XSS、CSRF、SQL注入。
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL知识点</title>
    <link href="http://yoursite.com/2020/05/20/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2020/05/20/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-05-20T03:09:35.000Z</published>
    <updated>2020-05-20T03:09:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h2><table><thead><tr><th>范式</th><th>描述</th><th>反例</th></tr></thead><tbody><tr><td>第一范式</td><td>每个字段都是原子的，不能再分解</td><td>某个字段是json串</td></tr><tr><td>第二范式</td><td>1. 表必须有主键；2. 非主属性，必须完全依赖主键，而不能只依赖主键的一部分字段。</td><td>如，好友关系表，关注人ID+被关注人ID作为主键，还存储了关注人的头像，这个只依赖于主键的一个字段。</td></tr><tr><td>第三范式</td><td>非主属性，直接依赖主键，而非间接依赖。</td><td>如，员工表，有部门ID和部门名称等，部门名称依赖的是部门ID，而不是员工ID，不应在员工表中。</td></tr></tbody></table><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>比如电商订单表，有三个查询纬度：订单ID，用户ID，商户ID。</p><ol><li>建立主纬度和辅助纬度之间的一个映射表<br>比如，以订单ID拆分，那么要保存<code>用户ID-&gt;订单ID</code>和<code>商户ID-&gt;订单ID</code>的映射表。然而问题是：<ol><li>映射表本身也要分表</li><li>每个订单，要写入多个库，属于分布式事务问题。通常会由后台任务，定时对比，保证多库表最终一致。</li></ol></li><li>业务双写<br>存多份数据，但是拆分纬度不一样。一套按用户ID划分，一套按商户号划分。同样存在写入多个库的分布式事务问题。</li><li>异步双写<br>还是多份数据，业务单写一份，然后通过监听binlog，同步到其他表上，这个方案整体更合适。</li><li>多个纬度统一到一个纬度<br>比如把订单ID和用户ID统一成一个维度，然后把用户ID作为订单ID的一部分。这样，订单ID中就包含了用户ID的信息，然后按照用户ID分库，当按订单ID查询的时候，提取出用户ID，再按用户ID确定在那哪个库表中。   </li></ol><p><strong>总之就是，拆分依据的维度，要同时在多个原始ID中体现</strong></p><h2 id="分库分表后的Join问题"><a href="#分库分表后的Join问题" class="headerlink" title="分库分表后的Join问题"></a>分库分表后的Join问题</h2><ol><li>join拆分为多个单表查询，在应用层代码里做join处理</li><li>增加宽表，提前join好</li><li>利用搜索引擎，比如ES，将DB数据导入ES中</li></ol><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><ol><li><strong>最好是优化业务，避免跨库事务</strong></li><li>如果无法避免，参考笔记：分布式事务一致性</li></ol><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>相比hash索引，以及类似结构的KV缓存或数据库，有以下特性</p><ol><li>范围查询</li><li>前缀匹配，模糊查询</li><li>排序和分页</li></ol><h3 id="2-物理结构"><a href="#2-物理结构" class="headerlink" title="2. 物理结构"></a>2. 物理结构</h3><ol><li>磁盘属于块设备，innoDB读写磁盘，是以page为基本单位，page默认大小是16KB，每次I/O都是16KB的整数倍。   </li><li>innoDB为每个Page赋予一个32位的全局编号，因此innoDB的存储上限是<strong>64T</strong> (2^32 * 16KB)。<br>如果用来装非叶子节点，假如key是64位整数，也就是8字节，加上其他字段，按16字节算，一个page可以装1000个key。基于此估算，一个三层的B+树，可以存储的数据量：<ol><li>第一层：根节点，一个page，1000个key。16KB内存，对应1000个子节点</li><li>第二层：1000个节点，每个节点一个page，每个page又可以有1000个子节点。16MB内存，对应1000 * 1000个子节点</li><li>第三层：1000 * 1000个节点，每个节点一个page。那么该表的最大容量是：1000 * 1000 * 16KB = 16GB。<strong>只需要16MB的内存索引，只需要一次I/O读取叶子节点</strong>    </li></ol></li><li>叶子page内部，以单向链表的方式，存储一条条的记录</li><li>非主键索引，索引树叶子节点存的是主键的value。</li></ol><h2 id="事务与锁"><a href="#事务与锁" class="headerlink" title="事务与锁"></a>事务与锁</h2><h3 id="1-隔离级别"><a href="#1-隔离级别" class="headerlink" title="1. 隔离级别"></a>1. 隔离级别</h3><table><thead><tr><th>隔离级别</th><th>解决问题</th></tr></thead><tbody><tr><td>Read Uncommited</td><td></td></tr><tr><td>Read commited</td><td>解决脏读</td></tr><tr><td>Repeatable Read</td><td>解决幻读（通过间隙锁），innoDB默认级别。MVCC需要结合行锁，实现当前读，解决update时的覆盖问题。</td></tr><tr><td>Serialization</td><td></td></tr></tbody></table><h3 id="2-死锁检测"><a href="#2-死锁检测" class="headerlink" title="2. 死锁检测"></a>2. 死锁检测</h3><ol><li>判断一个有向图是否存在环，dfs、拓扑排序</li><li>死锁的发生，与代码有关，也与事务隔离级别有关，因为隔离级别会影响加锁机制。</li><li>复杂度是O(N)</li></ol><h3 id="3-innoDB的MVCC实现"><a href="#3-innoDB的MVCC实现" class="headerlink" title="3. innoDB的MVCC实现"></a>3. innoDB的MVCC实现</h3><ol><li><p>每一行都有两个隐藏列，<strong>最近修改的事务ID</strong> + <strong>undolog里回滚段指针（便于回滚）</strong></p></li><li><p>一致性视图，{low_trx_id, up_trx_id, trx_ids}   </p><ul><li>low_trx_id: 当前事务链表，最小的事务id</li><li>up_trx_id:  当前事务链表，最大的事务id</li><li>trx_ids: 正在执行的事务的id集合   </li></ul><p> <strong>通过比较当前事务id，与以上三个变量的关系，确定某个版本数据，是否对当前事务可见。</strong></p></li></ol><h3 id="4-事务实现"><a href="#4-事务实现" class="headerlink" title="4. 事务实现"></a>4. 事务实现</h3><h4 id="1-WAL-Write-Ahead-Log"><a href="#1-WAL-Write-Ahead-Log" class="headerlink" title="1. WAL, Write-Ahead Log"></a>1. WAL, Write-Ahead Log</h4><p>内存操作数据 + write-ahead log，提高写入速度</p><h4 id="2-Redo-Log的逻辑与物理结构"><a href="#2-Redo-Log的逻辑与物理结构" class="headerlink" title="2. Redo Log的逻辑与物理结构"></a>2. Redo Log的逻辑与物理结构</h4><ol><li><p>redo log 物理组成结构</p><ol><li>一个逻辑事务 包含 多个物理事务mtr，Mini Transaction</li><li>每个mtr对应一个LSN</li><li>一个LSN对应若干个<strong>连续的block</strong>，所以每个mtr在redo log里是连续存储的，而整个事务的redo log不一定连续。</li><li>这些block，最终组成了 redo log   </li></ol><p> <strong>综上，一个事务在redo log里，可能有多个LSN，这些LSN自己是连续的，但是多个LSN不一定是连续的。</strong></p></li><li><p>redo log 日志内容格式</p><ol><li>先以page为单位记录日志</li><li>在每个page里面再采用物理记法，比如 (page_id, record_offset, (field1, value1)..(fieldi, valuei)…)   </li></ol></li><li><p>Aries恢复算法</p><ol><li>分析阶段<br>从上一个checkpoint开始，开始分析哪些事务执行完了，未刷写page；哪些事务执行了一半，需要回滚。checkpoint机制，可以加快分析速度</li><li>redo阶段<br>对已经commit的事务，执行redolog，刷写page。redolog是幂等的，重复执行没关系。</li><li>undo阶段<br>对于未commit的事务，执行undolog，回滚</li></ol></li><li><p>其他</p><ol><li>每个page上记录了，上次修改的LSN，因此恢复时，如果redolog里的 lsn &lt; page lsn，说明不用重写了。</li><li>redolog保证的是事务的持久性，写入成功，则不会丢失</li></ol></li></ol><h4 id="3-Undo-log"><a href="#3-Undo-log" class="headerlink" title="3. Undo log"></a>3. Undo log</h4><ol><li>redolog按LSN的顺序，而undolog没有顺序，多个事务并行写。每条日志除下记录主键ID和数据外，还有两个字段：修改记录的事务ID和回滚指针，用来串联所有历史版本，就是MVCC的两个隐藏列。</li><li>undo log 只在commit的过程中有用，一旦事务commit了，就可以删掉undo log</li><li>通俗一点，修改行前，先把行拷贝一份出来，这些历史版本形成一个链表。</li></ol><h2 id="各种锁"><a href="#各种锁" class="headerlink" title="各种锁"></a>各种锁</h2><ol><li>有不同的划分标准，比如按粒度，有<code>表锁</code>、<code>行锁</code>、<code>gap锁</code>；按锁的模式，有<code>共享锁</code>、<code>排他锁</code>、<code>意向锁</code>等</li><li>MySQL加锁问题与隔离级别有关，比如：Read Commited 级别不需要gap锁，因为RC允许幻读。</li><li>具体到各种锁<ol><li><code>全局锁</code>：对整个DB加锁，一些不支持事务的引擎，可以在备份前，锁住DB，避免备份时，一个读一个写，数据发生变化，造成数据不一致。</li><li><code>MDL</code>，元数据锁：MDL分读/写，不需显式调用。MDL也是在语句执行时隐式加，在事务提交后释放。比如在对表做CURD时，加MDL读锁；对表做DDL时，加MDL写锁。</li><li><code>表锁</code>，读锁/写锁，共享/排他，S/X，不赘述。</li><li><code>行锁</code>，读锁/写锁，共享/排他，S/X</li><li><code>意向锁</code>，意向锁也是表级别，但是意向锁之间互不排斥，包括IX（意向写）与IX也不互斥。<strong>意向锁的目的是提高在加表锁时的判断效率。</strong> 如果事务要给表中某一行加X锁，首先要对表加IX锁；如果要给某一行加S锁，就先对表加IS锁。这也是“意向”一词的含义。<br>如果一个事务要对表加X锁，就可以根据表有没有被其他事务加IS/IX锁，就可得知，有没有其他事务在读写该表。</li><li><code>间隙锁</code>，解决幻读问题</li><li><code>AI锁</code>，表级别，针对自增ID生成器，如果事务rollback，自增ID一列会不连续</li></ol></li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li><p>double write 机制   </p><p> InnoDB的page size一般是16KB，其数据校验也是针对这16KB来计算的，将数据写入到磁盘是以page为单位进行操作的。操作系统写文件是以4KB作为单位的，磁盘IO是以512字节为单位的，那么每写一个InnoDB的page到磁盘上，操作系统需要写4个块。<strong>而计算机硬件和操作系统，在极端情况下（比如断电）往往并不能保证这一操作的原子性。</strong><br> 如果16K的数据，写入4K时，发生了系统断电或系统崩溃，只有一部分写是成功的，这种情况下就是partial page write（部分页写入）问题。这时page数据出现不一样的情形，从而形成一个”断裂”的page，使数据产生混乱。这个时候InnoDB对这种块错误是无能为力的.   </p><p> 有人会认为系统恢复后，MySQL可以根据redo log进行恢复，而MySQL在恢复的过程中是检查page的checksum，如果会发现该page已经损坏，就无法确定上次修改page的事务id，因而在重放redolog时无法顺利恢复，即使重放了整个redo log，也无法严谨地证明数据完全恢复了。</p><p> 为了解决该问题，写数据page时，写两遍到磁盘，第一遍是写到double write buffer文件上, 第二遍是从double write buffer写到真正的数据文件中。如果宕机重启，发现page损坏，可以从double write buffer中恢复。   </p><p> 因为redo log的写入单位就是512字节，也就是磁盘IO的最小单位，因此可以保证原子性，不会导致数据损坏。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/0voice/interview_internal_reference/blob/master/09.MySQL%E7%AF%87/9.1.4%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E7%A7%8D%E7%B1%BB.md" target="_blank" rel="noopener">索引工作原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      总结一些mysql的知识点，包括范式、索引、事务、锁等等。
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>对CAP的正确理解</title>
    <link href="http://yoursite.com/2020/05/14/CAP/"/>
    <id>http://yoursite.com/2020/05/14/CAP/</id>
    <published>2020-05-14T03:06:27.000Z</published>
    <updated>2020-05-14T03:06:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ol><li>C，一致性，多副本一致性，事务一致性等</li><li>A，可用性</li><li>P，分区容忍性</li></ol><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>最大的误解：<strong>CAP可以三选二</strong><br>实际上P是必然存在的，只能在C和A（一致性和可用性）之间权衡。实际中大多是AP或CP系统，很少有CA的系统。</li><li>AP系统，追求可用性，放弃一致性。比如MySQL主从等。</li><li>CP系统，追求强一致性，牺牲一定的可用性。raft、zab协议。而此时的一致性，也只是对客户端看来是一致的，对内部看，是最终一致，因为同步数据总需要时间。</li><li>对于CA系统，因为要实现A（高可用），就必然有冗余，有冗余就必然存在P。比如MySQL，内部事务实现强一致性C，但是单机无法保证A，单机也不存在网络延迟，因此可以满足P。</li><li>只要引入冗余，实现的高可用（A），就一定存在P。如果还想兼顾一致性（C），那么一定不是真的A。<strong>因此实际系统中，总是在CA之间做权衡。放弃某一方，就变成了AP或CP。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CAP&quot;&gt;&lt;a href=&quot;#CAP&quot; class=&quot;headerlink&quot; title=&quot;CAP&quot;&gt;&lt;/a&gt;CAP&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;C，一致性，多副本一致性，事务一致性等&lt;/li&gt;
&lt;li&gt;A，可用性&lt;/li&gt;
&lt;li&gt;P，分区容忍性&lt;/li&gt;
&lt;/o
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Map并发安全实现原理</title>
    <link href="http://yoursite.com/2020/05/14/map%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/14/map%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-14T03:03:32.000Z</published>
    <updated>2020-05-14T03:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-Concurrent-hashmap"><a href="#Java-Concurrent-hashmap" class="headerlink" title="Java Concurrent hashmap"></a>Java Concurrent hashmap</h3><ol><li>多个segment，支持最大segment数量的并发访问<blockquote><p>ps: 如果hash桶的list过长，可以使用红黑树代替list</p></blockquote></li></ol><h3 id="golang-sync-Map"><a href="#golang-sync-Map" class="headerlink" title="golang sync.Map"></a>golang sync.Map</h3><ol><li>read-only, dirty 两个字段将读写分离</li><li>read-only不需加锁，读或写dirty都需要加锁</li><li>misses字段，统计read-only穿透次数，超过一定次数将dirty同步到read-only上</li><li>删除时，通过给read-only添加标记，延迟删除</li><li>读的时候，先查询read，不存在时查询dirty；写入时则只写入dirty</li><li>写入过程，每次写入时，先copy 未删除的read-only到dirty中，然后将k-v存入dirty。<blockquote><p>read-only可以当做dirty的缓存。dirty里的数据，总比read-only的多。</p></blockquote></li><li><strong>适用于读多写少的场景。写入较多时，性能无法保证。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java-Concurrent-hashmap&quot;&gt;&lt;a href=&quot;#Java-Concurrent-hashmap&quot; class=&quot;headerlink&quot; title=&quot;Java Concurrent hashmap&quot;&gt;&lt;/a&gt;Java Concurrent h
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>各种树结构</title>
    <link href="http://yoursite.com/2020/05/13/%E5%90%84%E7%A7%8D%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/05/13/%E5%90%84%E7%A7%8D%E6%A0%91%E7%BB%93%E6%9E%84/</id>
    <published>2020-05-13T02:21:07.000Z</published>
    <updated>2020-05-13T02:21:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="B树-vs-B-树-vs-B-树"><a href="#B树-vs-B-树-vs-B-树" class="headerlink" title="B树 vs B+树 vs B*树"></a>B树 vs B+树 vs B*树</h3><ol><li><p>B树，B是指发明人的名字</p><ul><li><p>平衡多路搜索树</p></li><li><p>保持键值有序，以顺序遍历</p></li><li><p>使用不完全填充的节点块，来加速插入和删除</p></li><li><p>节点块至少半满，提升空间利用率</p><p><img src="/images/b_tree.png" alt=""></p></li></ul></li><li><p>B+树 VS B树</p><ul><li><p>非叶子节点，只保存索引：从而可以减少索引树的大小，内存里可以保存更多的索引。由于每次都需要走到叶子节点，查询时间也更稳定。</p></li><li><p>叶子节点之间，增加链指针，方便遍历</p><p><img src="/images/b_plus_tree.jpg" alt=""></p></li></ul></li><li><p>B*树<br>在B+树的基础上</p><ul><li><p>非根和非叶子节点，增加指向兄弟的指针</p></li><li><p>插入时，如果节点已满，会检查兄弟节点是否满，未满，则向兄弟节点转移数据；已满，则从当前节点和兄弟节点，各拿出1/3数据，创建一个新节点。<br>从而节点空间利用率更高，节点分裂的情况也减少。</p><p><img src="/images/b_star_tree.jpg" alt=""></p></li></ul></li></ol><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ol><li><p>也是一种BST(二叉搜索树)，但是不要求完全平衡，比如：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</p></li><li><p>牺牲部分平衡性，达到较快的插入和删除性能</p></li><li><p>使用场景：linux CFS调度，nginx timer等</p></li><li><p>vs B树: B树作为多路搜索，能够在树深较小的情况下，支持更多的数据节点。对于磁盘类操作，可以避免大量的随机IO（一个磁盘page，可以读取到更多的索引，类似MySQL），从而优化读写性能。而红黑树一般整棵树都在内存里，不涉及到磁盘操作，支持的数据量较小，但是由于各种操作优于BST，因此常用于涉及到排序、搜索的场景。比如CFS，为了保证公平调度，每次选取当前执行总时间最小的线程执行。</p><p> <img src="/images/red_black_tree.png" alt=""></p></li></ol><h3 id="LSM，Log-Structured-Merged-Tree"><a href="#LSM，Log-Structured-Merged-Tree" class="headerlink" title="LSM，Log-Structured Merged Tree"></a>LSM，Log-Structured Merged Tree</h3><ol><li><p>核心思想：<strong>放弃部分读性能，提高写性能。</strong> 适用于kv存储。</p></li><li><p>内存中的memtable，磁盘上的sstable。读取的时候，需要遍历sstable，这里的 优化是，使用是bloom filter，确定一个Key是否在sstable里。</p></li><li><p>一般LSM-Trees会配合内存排序，内存里将写数据缓冲（通常是一个红黑树、跳表之类的结构）。等积累得足够多之后，使用归并排序将数据合并，写入磁盘。</p></li><li><p>应用：rocksDB，levelDB，hbase<br> 这些思想类似lsm，但也有一些优化和改进，比如levelDB为了避免sstable过多，以及降低sstable合并过程中的开销，增加了level的概念。如果没有level，新sstable需要和旧的sstable比较，随着数据量的增多，新sstable需要和越来越多的sstable合并，从而效率降低。（如果每次合并后只留下一个大的sstable，效率一样会降低，因为涉及到插入操作。）有了level，上下层level，待比较的相关sstable数量将会得到控制。从而加快压缩、合并的过程。<br> 除下按分层合并，还有按大小合并，hbase使用该种方法。两种思想，一种是更新的和更老的合并，一种是更小的和更大的合并。</p><p> sstable会保存所有写入的值（K-V），新的value并不会覆盖旧的value，而是读取的时候，从新的segment开始找，找到就停下。压缩、合并的过程，就是保留新的value，去除旧的value的过程。<br> 另外，为了防止系统崩溃，数据丢失，也会使用额外的WAL日志。相当于每次写入，需要更新有序的memtable，以及append WAL日志。   </p><p> Lucene(ES的索引引擎)，也是用了类似的思想存储它的倒排索引。首先根据类lsm思想找到单词对应的倒排索引值（文档ID列表），再根据文档ID，获取具体的文档。</p></li><li><p>参考资料</p><ul><li><a href="http://blog.fatedier.com/2016/06/15/learn-lsm-tree/" target="_blank" rel="noopener">http://blog.fatedier.com/2016/06/15/learn-lsm-tree/</a></li></ul></li></ol><h3 id="lsm-vs-b-树"><a href="#lsm-vs-b-树" class="headerlink" title="lsm vs b+树"></a>lsm vs b+树</h3><ol><li><p>查询过程<br>为了快速查询，一个办法是建立hash索引，但是hash索引占用空间太大，而且不支持区间查询。另一个办法是，事先对数据进行排序，B+树即为这种思想，把排序的操作放在了写入的时候，读的时候便轻松一些。   </p></li><li><p>写过程<br> 但是B树面对高并发写的时候，压力很大。B树把所有的压力都放到了写操作的时候，从根节点索引到数据存储的位置，可能需要多次读磁盘；真正插入的时候，持久化又可能会引起page的分裂，多次写磁盘。   </p><p> LSM在写的时候，直接写入内存，然后利用红黑树保持内存中的数据有序，由后台线程定期或被触发，去merge和持久化到磁盘。也会使用WAL方式记录log，避免数据丢失。  </p><p> 当写比读多时，LSM树相比于B树有更好的性能。因为随着insert操作，为了维护B树结构，节点分裂。读磁盘的随机读写概率会变大，性能会逐渐减弱。LSM把多次IO，变成一次IO，复用了磁盘寻道时间，极大提升效率。</p></li><li><p>总结下，通常LSM树的写入更快，B树的读取速度更快。 </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;B树-vs-B-树-vs-B-树&quot;&gt;&lt;a href=&quot;#B树-vs-B-树-vs-B-树&quot; class=&quot;headerlink&quot; title=&quot;B树 vs B+树 vs B*树&quot;&gt;&lt;/a&gt;B树 vs B+树 vs B*树&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;B树，B是
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
