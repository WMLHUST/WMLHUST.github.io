---
title: redis关键原理-1
tags: [redis]
categories: [后端,系统原理]
comments: true
date: 2020-08-18 15:32:44
updated: 2020-09-01 15:32:44
description:
---
## IO模型  

redis是单线程，使用epoll多路复用，来处理网络请求。特殊的时候会使用额外进程程，比如执行bgsave的时候，会fork一个子进程来创建RDB文件。

## 不同类型数据的实现  

### 字符串（GET/SET...）  

1. 存储结构：int/raw/embstr。  

- raw：redis里重要的sds对象，相比C的原生string，有一些优化，如：空间预分配、惰性释放、防溢出等。  
- embstr针对短字符串进行了优化，分配一块连续的空间；然而无法应对长度变化。

### 列表（LPUSH/RPUSH...）

1. 存储结构：linkedlist / ziplist  
- linkedlist: 双向链表
- ziplist: 压缩列表，在元素较小(<64字节)、较少(<512个)时使用，可以节约内存，可以计算出最大使用32kb。使用一块连续的内存，类似数组的内存实现。


### 哈希（HSET/HGET...）
1. 存储结构：hashtable / ziplist
- hashtable：
  - 使用单向链表解决冲突问题。
  - Hash算法使用 MurmurHash，计算速度快，冲突率低。
  - 如果hashtable的负载因子过大或过小，会执行扩展或收缩，会有一个rehash动作。但是整个rehash动作不是一次性完成的，而是一个渐进的过程：**将rehash分摊到每个添加、删除、查找和更新操作上，避免rehash巨大的工作量阻塞redis服务。** 比如如果要查找，会同时在新旧hashtable里查找。

- ziplist：  
使用压缩列表同样是为了节省内存，也同样是在元素较小(<64byte)、较少(<512)个时使用。此时hget的时间复杂度就不是O(1)了，而是O(N)，不过由于元素不多，查找耗时影响不明显。

### 集合 (SADD/SREM...)
1. 存储结构
- hashtable：值为NULL
- intset，整数集合：  
类似**有序的整数数组**，也是为了节省内存，只有元素都是整数、数量较少(<512个)时使用。
  
### 有序集合（ZADD/ZREM...）
1. 存储结构
- skiplist 和 hashtable
    - skiplist，大名鼎鼎的跳跃表，优点是：实现较为简单，然而平均查找效率可以达到O(logN)级别。
    - 对于跳跃表的结构、查找、插入过程可以参考网上的一些资料，或者查看[redis的源码](https://github.com/redis/redis/blob/unstable/src/t_zset.c)，非常简洁。
    - hashtable，主要是为了加快ZSCORE的速度，如果仅用skiplist，ZSCORE的时间复杂度是O(logN)，有了hashtable，复杂度可以降至O(1)。（空间、时间互换的思想到处都是啊，朴素的原理）
    
- ziplist，同样是为了降低内存占用，只有元素较小（<64字节）、较少(<128个)时使用

### Expire的过期淘汰策略
1. 定时删除：  
在设置键过期时间的同时，创建定时器timer，到期后，立刻删除该键。  
定时删除策略，对内存最友好，对CPU最不友好，处理大量的timer，也会占用很多CPU。

2. 惰性删除：  
redis在访问键的时候，检查过期时间。  
对CPU最友好，但是对内存不友好。如果一个键过期后，不再访问到，将一直占用内存。

3. 定期删除：
每隔一段时间，对redis进行一次检查，删除里面的过期键。  
**需要合理设置触发频率和执行时长。**  

redis同时使用惰性删除和定期删除两种策略。

### 哨兵Sentinel
1. 哨兵是redis高可用的一个方案。可以用来监视redis主从集群的运行状况，及时替换故障节点。  
sentinel也可以有多个，形成集群，共同监视redis集群。  
2. sentinel默认每10s使用info命令，探测一次主机的在线状态，也可以根据主机的回复，自动发现从机。
3. sentinel会订阅节点的__sentinel__:hello频道，也会通过给节点发送pub命令，往该频道发送消息。如此，多个sentinel便可互相探测到。  
4. 多个sentinel时，会自动选举一个leader，选举算法是raft。发生故障时，以leader sentinel的决策为准。   
5. 如果redis主机挂掉，sentinel选新的主机时，会根据优先级和复制偏移量确定选哪个从机。  

### redis cluster，分片集群
1. 节点信息（比如负责的slot区间）的传播使用gossip协议
2. 集群分为16384个slot，集群中的每个节点可以处理0~16384个slot。只有每个slot都有节点在处理，集群才处于上线状态。每个节点都会记录，所有slot的指派节点。
3. 节点收到命令时，会计算键属于哪个slot，如果slot不属于自己负责，则会向client返回一个MOVED IP:PORT错误，客户端再次向正确的节点发送请求。
4. 重新分片，类似rehash的过程，不过这个是批量的，而非渐进式的。迁移过程中的查询过程与rehash过程类似。


### 其他
1. 共享对象：对于整数型的数据，redis可以在不同kv间共享，来减少内存使用。对字符串不共享，因为字符串的比较复杂度是O(N)，而数字是O(1)。
2. redis使用引用计数来回收内存，不用担心循环引用，因为引用关系简单
3. 主从模式下，过期键的删除由主机控制，从机不会主动删除过期键，而会等待主机删除时发过来的DEL命令控制。造成的问题是，如果键过期，主机未删除，在从机还会正常读到。
4. 主从同步过程：  
   - master 执行bgsave 备份rdb镜像，并同时将后续修改操作记录到内存buffer
   - master备份完成后，先将rdb文件传输给slave
   - slave将rdb镜像加载到内存，之后重放master备份期间的修改即可
 
5. 如果一个主机有多个从机，那么当主机故障时，多个从机会选举出一个主机，选举算法同样基于raft。
6. redis有个周期函数，每100ms执行一次，来对正在运行的服务器进行维护。比如：执行定期删除策略、检查是否满足save条件等。
7. RDB文件是二进制格式，会对KV进行压缩，存储KV的时候，大致是Type-Key-Value的形式。
8. AOF包含的只有写命令。为了解决AOF文件体积膨胀的问题，可以执行AOF重写操作。在执行BGREWRITEAOF命令时，redis会维护一个AOF重写缓冲区，记录执行期间的所有写命令。子进程重写AOF完成后，再将缓冲区的内容，追加到新的AOF文件末尾，解决重写AOF期间的命令丢失问题。
9.  redis的复制：关键点在于同步和命令传播。同步是在从机启动时，直接将主机的RDB文件拉过来；同步成功后，会进入命令传播阶段，主机会将每一个写命令同步给从机。2.8版本以前，即使命令在传播过程中丢失，主、从都不会注意到，也不会重传。2.8版本及以后，增加了offset的概念，来实现部分同步和命令重传。
10. 当前的redis订阅&消费模式，不会保存消息，如果publish时，subscriber不在线，将错过这条消息。更没有对消息持久化的操作。简单地理解，消息只会发送给当时在线的消费者。
11. multi vs pipeline：
    - multi命令缓冲在server，pipeline缓冲在client
    - multi，每个命令client会发送一次，pipeline是一次发送积累的多个命令
    - multi/exec可以保证多个命令的执行在一个原子操作中，不被其他client的命令打断，pipeline不保证
12. WATCH命令，在exec时，检查watched keys，如果value发生了变化，就拒绝执行
13. redis事务和传统RDBMS事务，最大的区别在于，redis不支持回滚，即使事务队列的某个命令执行期间出错，整个事务也会继续执行剩下的命令。因此可以说，不满足原子性的要求：要么全部成功，要么全部失败。对于C一致性、I隔离性、D持久性，redis是可以满足的。










