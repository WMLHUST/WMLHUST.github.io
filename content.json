{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-05-11T09:14:14.000Z","updated":"2020-05-11T09:14:36.963Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-11T09:10:36.000Z","updated":"2020-05-11T09:11:52.492Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-05-11T09:20:22.000Z","updated":"2020-05-11T09:22:25.642Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"about about"}],"posts":[{"title":"map并发安全实现原理","slug":"map并发安全实现原理","date":"2020-05-14T03:03:32.000Z","updated":"2020-05-14T03:03:32.000Z","comments":true,"path":"2020/05/14/map并发安全实现原理/","link":"","permalink":"http://yoursite.com/2020/05/14/map%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"Java Concurrent hashmap 多个segment，支持最大segment数量的并发访问 ps: 如果hash桶的list过长，可以使用红黑树代替list golang sync.Map read-only, dirty 两个字段将读写分离 read-only不需加锁，读或写dirty都需要加锁 misses字段，统计read-only穿透次数，超过一定次数将dirty同步到read-only上 删除时，通过给read-only添加标记，延迟删除 读的时候，先查询read，不存在时查询dirty；写入时则只写入dirty 写入过程，每次写入时，先copy 未删除的read-only到dirty中，然后将k-v存入dirty。 read-only可以当做dirty的缓存。dirty里的数据，总比read-only的多。 适用于读多写少的场景。写入较多时，性能无法保证。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"各种树结构","slug":"各种树结构","date":"2020-05-13T02:21:07.000Z","updated":"2020-05-13T02:21:07.000Z","comments":true,"path":"2020/05/13/各种树结构/","link":"","permalink":"http://yoursite.com/2020/05/13/%E5%90%84%E7%A7%8D%E6%A0%91%E7%BB%93%E6%9E%84/","excerpt":"","text":"B树 vs B+树 vs B*树 B树，B是指发明人的名字 平衡多路搜索树 保持键值有序，以顺序遍历 使用不完全填充的节点块，来加速插入和删除 节点块至少半满，提升空间利用率 B+树 VS B树 非叶子节点，只保存索引：从而可以减少索引树的大小，内存里可以保存更多的索引。由于每次都需要走到叶子节点，查询时间也更稳定。 叶子节点之间，增加链指针，方便遍历 B*树在B+树的基础上 非根和非叶子节点，增加指向兄弟的指针 插入时，如果节点已满，会检查兄弟节点是否满，未满，则向兄弟节点转移数据；已满，则从当前节点和兄弟节点，各拿出1/3数据，创建一个新节点。从而节点空间利用率更高，节点分裂的情况也减少。 红黑树 也是一种BST(二叉搜索树)，但是不要求完全平衡 牺牲部分平衡性，达到较快的插入和删除性能 使用场景：linux CFS调度，nginx timer等 vs B树: B树作为多路搜索，能够在树深较小的情况下，支持更多的数据节点。对于磁盘类操作，可以避免大量的随机IO（一个磁盘page，可以读取到更多的索引，类似MySQL），从而优化读写性能。而红黑树一般整棵树都在内存里，不涉及到磁盘操作，支持的数据量较小，但是由于各种操作优于BST，因此常用于涉及到排序、搜索的场景。比如CFS，为了保证公平调度，每次选取当前执行总时间最小的线程执行。 LSM，Log-Structured Merged Tree 核心思想：放弃部分读性能，提高写性能。适用于kv存储 应用：rocksDB，levelDB，hbase rocksDB：c++编写的kv存储引擎 levelDB：kv存储引擎 hbase: 分布式存储，列数据库，应对大量数据（亿级以上） 内存中的memtable，磁盘上的sstable。读取的时候，需要遍历sstable，这里的 优化是，使用是bloom filter，确定一个Key是否在sstable里。 一般LSM-Trees会配合内存排序，内存里将写数据缓冲（通常是一个(Red-Black Tree)红黑树结构）。等积累得足够多之后，使用归并排序将数据合并，写入磁盘。由于。 参考资料 http://blog.fatedier.com/2016/06/15/learn-lsm-tree/ lsm vs b+树 查询过程为了快速查询，一个办法是建立hash索引，但是hash索引占用空间太大，而且不支持区间查询。另一个办法是，事先对数据进行排序，B+树，把排序的操作放在了写入的时候，读的时候便轻松一些。 写过程 但是B树面对高并发写的时候，压力很大。B树把所有的压力都放到了写操作的时候，从根节点索引到数据存储的位置，可能需要多次读文件；真正插入的时候，又可能会引起page的分裂，多次写文件。 LSM在写的时候，直接写入内存，然后利用红黑树保持内存中的数据有序，由后台线程定期或被触发，去merge和持久化到磁盘。也会使用WAL方式记录log，避免数据丢失。 当写比读多时，LSM树相比于B树有更好的性能。因为随着insert操作，为了维护B树结构，节点分裂。读磁盘的随机读写概率会变大，性能会逐渐减弱。LSM把多次IO，批量变成一次IO，复用了磁盘寻道时间，极大提升效率。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"分布式锁","slug":"分布式锁","date":"2020-05-12T13:35:11.000Z","updated":"2020-05-12T13:35:11.000Z","comments":true,"path":"2020/05/12/分布式锁/","link":"","permalink":"http://yoursite.com/2020/05/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"","text":"redis set key val nx ex 优点：实现简单，性能好 缺点：超时时间不好控制，极端情况，会出现超时后，多个节点获取到同一把锁的情况。 问题 主从，redis主从采用异步复制，那么如果主机宕机，切换到从，会导致部分锁数据丢失。此时，多个client会拿到同一把锁。 如果锁没有设置超时，若client挂掉，则锁永远不会释放 如果锁设置了超时，若client阻塞或业务执行超时，也会导致多个client拿到同一把锁。 zookeeper 使用临时顺序节点，如果自己是子节点的第一个，则表示加锁成功。否则，watch上一个，如果上一个释放，表示轮到自己了。 优点：一般情况，不存在client宕机/超时问题，zk感知到client宕机，会自动删除对应的临时顺序节点，相当于自动释放锁，或者取消自己的排队。 缺点：实现复杂，吞吐量不高 问题 因为zk使用心跳判断client是否在线，如果网络超时或者full GC等等，导致zk认为client宕机，则会释放锁。导致其他client同时获得该锁。但是这种情况很少见，相比之下，client处理超时这种更常见，这也是zk比redis方案好的原因。 mysql行锁 优点：不需引入额外中间件 缺点：吞吐量不高；也存在client宕机超时问题 总结 探测client是否宕机很难，如果因为超时，那就不应该释放锁。如果是因为宕机，那就应该释放锁。 没有完美的方案，实际场景中，分布式锁只应作为辅助手段，比如为了减少DB的压力等，不应仅靠它控制业务并发逻辑。","categories":[{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"方案总结","slug":"分布式/方案总结","permalink":"http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"高并发常见方案","slug":"高并发","date":"2020-05-12T13:29:38.000Z","updated":"2020-05-12T13:29:38.000Z","comments":true,"path":"2020/05/12/高并发/","link":"","permalink":"http://yoursite.com/2020/05/12/%E9%AB%98%E5%B9%B6%E5%8F%91/","excerpt":"","text":"高并发写 数据分片 数据库分库分表 JDK concurrentHashMap实现 kafka的partition ES的分布式索引 任务分片 CPU的指令流水线 Map/Reduce Tomcat 1+N+M 网络模型：1个监听线程，N个IO线程负责对socket进行读写，M个worker对请求做逻辑处理。 异步化：异步接口、异步IO 短信验证码注册/登录 订单系统 广告计费系统，异步，多消息合并扣费 Kafka的Pipeline WAL技术 数据库redo log LSM树 批量 kafka的百万qps写入:partition分片，磁盘顺序写入，批量（leader/follower之间的批量，本地client之间的批量） mysql的group commit机制，对多事务的redo log批量flush 高并发读 加缓存 本地缓存/redis/memcached 增加副本冗余 MySQL master/slave CDN 静态文件加速 并发读 异步RPC 冗余请求，降低失败率","categories":[{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"方案总结","slug":"分布式/方案总结","permalink":"http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"多副本一致性","slug":"多副本一致性","date":"2020-05-12T03:23:33.000Z","updated":"2020-05-12T05:09:02.394Z","comments":true,"path":"2020/05/12/多副本一致性/","link":"","permalink":"http://yoursite.com/2020/05/12/%E5%A4%9A%E5%89%AF%E6%9C%AC%E4%B8%80%E8%87%B4%E6%80%A7/","excerpt":"","text":"同步本质每台机器都把收到的请求按日志存下来，各机器的日志文件保持一致。选择存储“事件流”，而非最终状态，原因是： 日志只有一种操作，append，相对简单 Paxos算法1. Basic Paxos 两个角色，Proposer 和 Acceptor，以及一个自增ID（n） 两个阶段，Propose阶段 和 Accept 阶段 Propose阶段 proposer广播消息，id为n，prepare(n) acceptor接收消息，如果n &gt; local N，则回复yes proposer收到半数以上的yes，开始广播，否则id自增，重新广播 Acctpt阶段 proposer广播消息, accept(n, value) acceptor接收消息，如果n &gt; loacal N，则持久化，返回yes proposer收到半数以上的yes，则结束。否则id自增，从proposer阶段重新开始。 两个问题 Paxos是个不断循环的2PC，有可能陷入死循环，所谓“活锁”。比如3个node同时propose，都收到no，又同时n++，继续propose，继续no 性能：每次写入，需要两次RTT + 两次写盘。两次RTT分别是Propose/Accept阶段。这两个阶段都会持久化一些变量，需要磁盘IO。 活锁问题 多点写入，变为单点写入。选出一个leader，只让leader当proposer。从而减少冲突。leader选取办法，比如每个节点增加编号，使用心跳，选取编号最大的节点为leader。即使出现同一时间，多个leader，也不影响paxos的正确性，只会增大并发写冲突的概率。 Raft算法 单点写入：任一时刻，只允许一个有效的leader存在，所有的写请求，都传到leader上，然后由leader同步给超过半数的follower。 单条日志结构：term + index + content。term是leader的任期，只会单调递增；index是日志顺序编号，也是递增； 分为三个阶段，选举阶段，正常阶段，恢复阶段 选举阶段 节点有三个状态：leader、follower、candidate。candidate是个中间状态。 当follower在一定时间收不到leader心跳时，就会随机sleep一个时间，然后变为candidate，发起选举。选举结束后，变为leader或follower。 选举算法，保证同一时间只有一个leader。 如果选举请求里，日志的term和index比自己本地的新，则返回true，否则返回false。 candidate收到多数派返回true，则成为leader 每个节点只能投一次true，防止多个leader。因此选取出的leader不一定是最新的，但一定比大多数节点新。 正常阶段，复制日志 只要超过半数的follower复制成功，就返回给客户端日志写入成功。 关键的日志一致性保证： 如果两个节点的日志，index和term相同，则内容一定相同。 如果index=M处的日志相同，则在M之前的日志，也一定相同。 恢复阶段 leader同步term给follower 以leader本地的日志为基准，复制给follower 安全性保证 leader数据是基准，leader不会从别的节点同步数据，只会是别的节点根据leader数据删除或追加自己的数据。 对于已经commit的日志，一定是commit的。对于新任leader上，前任leader未commit的日志，稍后会变为commit状态。不在新任leader上的未commit数据，会被覆盖。 Zabzookeeper使用的强一致性算法，同时也是单点写入，写请求都转发给leader。 模型对比，复制状态机(replicated state machine, paxos/raft) vs 主备系统（primay-backup system，zab）,前者持久化的是客户端的请求序列（日志序列），另外一个持久化的是数据的状态变化。 数据同步次数不一样，如果client执行三次x=1，后两次在主备系统里，不用触发同步。 存储状态变化，具有幂等性，而复制状态机不具备。 zxid 高32位，leader任期，类似raft的term 低32位，日志序列，类似raft的日志index 三个阶段：Leader选举，BroadCast,恢复阶段 Leader选举：FLE算法 Leader和Follower之间是双向心跳；raft里是单向 选取zxid最大的节点作为leader；和raft选取term+index最新的节点作为leader一个意思。 broadcast阶段 raft vs zab参考：https://my.oschina.net/pingpangkuangmo/blog/782702 上一轮残留的数据怎么处理？ 首先看下上一轮次的leader在挂或者失去leader位置之前，会有哪些数据？ 已过半复制的日志 未过半复制的日志一个日志是否被过半复制，是否被提交，这些信息是由leader才能知晓的， 那么下一个leader该如何来判定这些日志呢？ 下面分别来看看Raft和ZooKeeper的处理策略： Raft：对于之前term的过半或未过半复制的日志采取的是保守的策略，全部判定为未提交，只有当当前term的日志过半了，才会顺便将之前term的日志进行提交 ZooKeeper：采取激进的策略，对于所有过半还是未过半的日志都判定为提交，都将其应用到状态机中 Raft的保守策略更多是因为Raft在leader选举完成之后，没有同步更新过程来保持和leader一致（在可以对外服务之前的这一同步过程）。而ZooKeeper是有该过程的","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"系统原理","slug":"后端/系统原理","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"开天辟地","slug":"开天辟地","date":"2020-05-11T09:05:19.000Z","updated":"2020-05-14T03:04:18.669Z","comments":true,"path":"2020/05/11/开天辟地/","link":"","permalink":"http://yoursite.com/2020/05/11/%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0/","excerpt":"","text":"欢迎","categories":[],"tags":[]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"方案总结","slug":"分布式/方案总结","permalink":"http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"},{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"系统原理","slug":"后端/系统原理","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]}