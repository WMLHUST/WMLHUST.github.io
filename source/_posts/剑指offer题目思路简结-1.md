---
title: 剑指offer题目思路简结-1
tags: [leetcode]
categories: []
comments: true
date: 2020-06-22 14:54:13
updated: 2020-06-22 14:54:13
description: 剑指offer 1-23 题，思路简结
---
<!-- TOC -->

1. [剑指 Offer 03.数组中重复的数字](#剑指-offer-03数组中重复的数字)
2. [剑指 Offer 04. 二维数组中的查找](#剑指-offer-04-二维数组中的查找)
3. [剑指 Offer 05. 替换空格](#剑指-offer-05-替换空格)
4. [剑指 Offer 06. 从尾到头打印链表](#剑指-offer-06-从尾到头打印链表)
5. [剑指 Offer 07. 重建二叉树](#剑指-offer-07-重建二叉树)
6. [剑指 Offer 09. 用两个栈实现队列](#剑指-offer-09-用两个栈实现队列)
7. [剑指 Offer 10- I. 斐波那契数列](#剑指-offer-10--i-斐波那契数列)
8. [剑指 Offer 10- II. 青蛙跳台阶问题](#剑指-offer-10--ii-青蛙跳台阶问题)
9. [剑指 Offer 11. 旋转数组的最小数字](#剑指-offer-11-旋转数组的最小数字)
10. [剑指 Offer 12. 矩阵中的路径](#剑指-offer-12-矩阵中的路径)
11. [剑指 Offer 13. 机器人的运动范围](#剑指-offer-13-机器人的运动范围)
12. [剑指 Offer 14- I. 剪绳子](#剑指-offer-14--i-剪绳子)
13. [剑指 Offer 14- II. 剪绳子 II](#剑指-offer-14--ii-剪绳子-ii)
14. [剑指 Offer 15. 二进制中1的个数](#剑指-offer-15-二进制中1的个数)
15. [剑指 Offer 16. 数值的整数次方](#剑指-offer-16-数值的整数次方)
16. [剑指 Offer 17. 打印从1到最大的n位数](#剑指-offer-17-打印从1到最大的n位数)
17. [剑指 Offer 18. 删除链表的节点](#剑指-offer-18-删除链表的节点)
18. [剑指 Offer 19. 正则表达式匹配](#剑指-offer-19-正则表达式匹配)
19. [剑指 Offer 20. 表示数值的字符串](#剑指-offer-20-表示数值的字符串)
20. [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](#剑指-offer-21-调整数组顺序使奇数位于偶数前面)
21. [剑指 Offer 22. 链表中倒数第k个节点](#剑指-offer-22-链表中倒数第k个节点)
22. [剑指 Offer 24. 反转链表](#剑指-offer-24-反转链表)
23. [剑指 Offer 25. 合并两个排序的链表](#剑指-offer-25-合并两个排序的链表)

<!-- /TOC -->

## 剑指 Offer 03.数组中重复的数字
直接使用hash即可，高级一点的使用bitmap也可

## 剑指 Offer 04. 二维数组中的查找
关键在于，利用规律缩小查找范围。   
1. 如果target < 当前的数，那么它就不可能在target同一行的左边
2. 每一列都按照从上到下递增的顺序排序：那么如果target > 当前的数，那么它就不可能在target同一列的上面  

从右上角开始找，一点一点缩小范围。

## 剑指 Offer 05. 替换空格
1. 如果用python/java/golang之类的，可以直接拼接字符串。动态分配内存。   
2. 如果用c/c++，就需要预分配内存，因此需要先遍历一遍，计算有多少个空格，从而计算结果字符串所需内存大小。

## 剑指 Offer 06. 从尾到头打印链表
1. 解法一：先遍历，再对结果数组反转
2. 解法二：使用栈暂存节点，然后弹出栈 

## 剑指 Offer 07. 重建二叉树
关键点：
1. 前序遍历的第一个节点，是当前节点的root；但是没法区分剩余节点，哪些是左、右子树
2. 根据root，可以把中序遍历，分为左右子树两部分；借此得知左右子树的节点数量，也就能把前序遍历剩余节点分开
3. 对前序遍历拆分的左右子树，递归求解

## 剑指 Offer 09. 用两个栈实现队列
关键点：
1. 两个栈，一个是input栈，一个是output栈，分别只负责input和output
2. output没了，就从input里转移到output   

时间复杂度，O(1)；空间复杂度，O(n)

## 剑指 Offer 10- I. 斐波那契数列
递归、迭代解法，不再赘述。   
值得一提的是，对于递归类题目，有两个关键点：
1. 递归子问题
2. 递归终止条件，这个不能忘，否则会stackoverflow   

尤其是二叉树类的问题，天生合适递归。把一个二叉树的问题，转换为，分别针对左右子树的两个子问题。

## 剑指 Offer 10- II. 青蛙跳台阶问题
同 [剑指 Offer 10- I. 斐波那契数列](#剑指-offer-10--i-斐波那契数列) 斐波那契数列。

## 剑指 Offer 11. 旋转数组的最小数字
二分法，确定min_index在[left, mid]，还是在[mid, right]之间。注意下极端条件，比如：翻转0个的情况；所有数都相等的情况；最后剩余两个数的情况；mid和边界相等的情况等等

## 剑指 Offer 12. 矩阵中的路径
DFS

## 剑指 Offer 13. 机器人的运动范围
BFS，当然DFS也可以，不过BFS最合适，相当于一圈一圈地扩展范围

## 剑指 Offer 14- I. 剪绳子
简单的动态规划，顺带提一下动态规划的三个关键点：
1. 划分子问题：一个大问题可以拆分为多个子问题，并且在大问题是最优解时，拆分出来的子问题也都是最优解的状态。
2. 状态转移公式
3. 边界条件   

是不是很像递归，因为动态规划一个最简单的实现方式就是递归。对于该题，三个关键点分别是：
1. 划分子问题：长度为n的绳子，最大乘积，等于将其分一部分、两部分、多部分的最大值。
2. 状态转移公式：F(n) = max( (n-i) * F[i] for i in range(1, n))
3. 边界条件：F(0) = 1; F(1) = 1   

另外，由于该题要求至少分两段，因此需要对长度为最长时，稍微做一点特殊处理。

如果是递归实现，是会提示超时的，因为其中存在很多重复的计算。可以用递归的另外两种实现方式：备忘录法，自底向上法。

还有一种解法是根据数学规律，将n分为尽量多个3。这种解法不具通用性，就不介绍了。

## 剑指 Offer 14- II. 剪绳子 II
在 [剑指 Offer 14- I. 剪绳子](#剑指-offer-14--i-剪绳子) 基础上，多了大数，就直接使用long类型，然后取模吧。

## 剑指 Offer 15. 二进制中1的个数
经典位运算题。n的每一位与 1 做 与操作，直到n变为0。

## 剑指 Offer 16. 数值的整数次方
关键点，利用二分思想：   

```python
pow(x, n) = pow(x, n//2) ** 2  # n为偶数   
pow(x, n) = pow(x, n//2) ** 2 * x  # n为奇数   
```

## 剑指 Offer 17. 打印从1到最大的n位数
最大的n位数，是 pow(10, n)-1，遍历即可。   
小心大数越界，如果是面试。

## 剑指 Offer 18. 删除链表的节点
不再赘述。   
值得一提：链表类问题，可以增加一个头结点dummy_head，这样可以使边界情况，处理起来方便很多。

## 剑指 Offer 19. 正则表达式匹配
动态规划：（主串S, 模式串T）   

1. 划分子问题：如果S和T匹配，那么S和T的子串也匹配

2. 状态转移公式：   
为了避免每次都要检查，后一个字符串是否是"*"，从后往前遍历。
    ```
    1. T[i] 是普通字符
        F(S, T) = S[i] == T[i] && F(S[:-1], T[:-1])

    2. T[i] == '.'，可以匹配任何字符
        F(S, T) = F(S[:-1], T[:-1])

    3. T[i] == '*'，*前面的字符可以重复0次或多次
        
        3.1 S=="", 说明*前面的字符重复0次
            F(S, T) = F(S, T[:-2])

        3.2 T[-2] == '.' 或 S[-1] == T[-2]，前一个字符能匹配上，则需考虑匹配0次、和多次的情况
            F[S, T] = F(S, T[:-2]) || F(S[:-1], T)   

        3.3 S[-1] != T[-2]，前一个字符不匹配，相当于匹配了0次
            F(S, T) = F(S, T[:-2])
    ```

3. 边界条件:   
边界条件，就是S、T一直递归匹配，直到某一个变为了空字符串
    ```
    1. S == "" && T == ""，return True

    2. S == "" && T != "", 需要继续匹配，比如 S=”“， T="a*"，是匹配的

    3. S != "" && T == "", return False
    ```

## 剑指 Offer 20. 表示数值的字符串
非常典型的一道`有限状态机`题，重点在于划分不同的状态，怕错不怕重复。状态之间的转移相对容易。

## 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面
两个指针，pre指针从头开始遍历，post指针指向尾。每次pre指向一个偶数，就将其与post交换，直到两指针相遇。

## 剑指 Offer 22. 链表中倒数第k个节点
快慢指针，不做赘述。

## 剑指 Offer 24. 反转链表
三个指针，循环遍历即可。注意边界条件。

## 剑指 Offer 25. 合并两个排序的链表
添加一个dummy头结点，然后对两个链表，执行类似一个归并排序的操作。
